<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Helios C2 Demo</title>
  <style>
    :root {
      --bg: #0b1224;
      --panel: #111a30;
      --accent: #4cf0b5;
      --muted: #9ab0d6;
      --text: #e8ecf5;
      --warn: #f9c74f;
      --error: #f94144;
      --card: linear-gradient(135deg, rgba(76, 240, 181, 0.07), rgba(76, 150, 240, 0.04));
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 12px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'IBM Plex Sans', system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(76, 240, 181, 0.08), transparent 35%),
                  radial-gradient(circle at 80% 10%, rgba(76, 150, 240, 0.08), transparent 30%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    header {
      position: sticky;
      top: 0;
      backdrop-filter: blur(8px);
      background: rgba(11,18,36,0.7);
      border-bottom: 1px solid rgba(255,255,255,0.05);
      z-index: 10;
      padding: 16px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    nav a {
      color: var(--muted);
      margin-right: 16px;
      text-decoration: none;
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    nav a.active, nav a:hover { color: var(--accent); }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      font-size: 12px;
    }
    .container { max-width: 1100px; margin: 0 auto; padding: 24px; }
    h1 { margin: 0 0 8px; letter-spacing: 0.01em; }
    .grid { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
    .kpi-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 12px; }
    .kpi {
      padding: 14px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(135deg, rgba(76, 240, 181, 0.14), rgba(76, 150, 240, 0.06));
      box-shadow: var(--shadow);
    }
    .kpi .label { color: var(--muted); font-size: 12px; letter-spacing: 0.03em; text-transform: uppercase; }
    .kpi .value { font-size: 24px; font-weight: 700; }
    .card {
      background: var(--card);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
    }
    .card h3 { margin: 0 0 6px; }
    .muted { color: var(--muted); font-size: 14px; }
    .badge { display: inline-block; padding: 4px 8px; border-radius: 8px; font-size: 12px; font-weight: 700; }
    .badge-live { background: rgba(76, 240, 181, 0.16); color: var(--accent); }
    .badge-mock { background: rgba(249, 65, 68, 0.12); color: var(--error); }
    pre {
      background: #0d152b;
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: var(--radius);
      padding: 12px;
      overflow: auto;
      color: var(--muted);
      white-space: pre-wrap;
      word-break: break-word;
    }
    button {
      background: linear-gradient(135deg, #4cf0b5, #4c96f0);
      color: #0a1020;
      font-weight: 700;
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(76, 240, 181, 0.35);
      transition: transform 0.1s ease, box-shadow 0.2s ease;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 12px 34px rgba(76, 240, 181, 0.45); }
    button:active { transform: translateY(0); }
    .status-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .status-row.wrap { flex-wrap: wrap; gap: 6px; align-items: flex-start; }
    .status-row.wrap select { flex: 1 1 180px; min-width: 180px; max-width: 100%; }
    .card-head { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .card-toggle { border: none; background: none; color: var(--muted); cursor: pointer; font-weight: 700; font-size: 12px; padding: 2px 6px; }
    .card-toggle:hover { color: var(--accent); }
    .collapsible-card.collapsed .collapsible-body { display: none; }
    .small { font-size: 12px; }
    .panel { margin: 24px 0; padding: 16px; border-radius: var(--radius); background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06); }
    .toolbar { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .chip {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      cursor: pointer;
      font-weight: 600;
    }
    .chip.active { border-color: var(--accent); color: var(--accent); box-shadow: 0 8px 20px rgba(76,240,181,0.25); }
    .table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      color: var(--muted);
    }
    .table th, .table td {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      text-align: left;
      word-break: break-word;
      white-space: normal;
    }
    .table th { color: var(--text); font-size: 12px; letter-spacing: 0.03em; text-transform: uppercase; }
    input[type="number"], input[type="text"], textarea {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
      padding: 6px 8px;
      border-radius: 8px;
      width: 100%;
    }
    textarea { min-height: 72px; resize: vertical; }
    .list { list-style: none; padding-left: 0; margin: 0; }
    .list li { padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.06); color: var(--muted); white-space: normal; word-break: break-word; }
    .scroll { max-height: 260px; overflow: auto; }
    .pill-button { padding: 8px 12px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.05); color: var(--text); cursor: pointer; }
    .pill-button:hover { border-color: var(--accent); color: var(--accent); }
    a.link { color: var(--accent); text-decoration: none; }
    .hero {
      padding: 18px 16px 12px;
      border-radius: var(--radius);
      background: linear-gradient(135deg, rgba(76, 240, 181, 0.12), rgba(76, 150, 240, 0.10));
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: var(--shadow);
      margin-bottom: 18px;
    }

    .info-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .info-card {
      background: rgba(13, 21, 43, 0.55);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      padding: 12px;
    }
    .info-card .title {
      font-weight: 800;
      letter-spacing: 0.02em;
      font-size: 12px;
      text-transform: uppercase;
      color: var(--text);
      margin-bottom: 6px;
    }
    .info-card .body {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    /* -------------------- Natural Language Blocks -------------------- */
    .nl {
      background: rgba(13, 21, 43, 0.55);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      padding: 12px;
      color: var(--text);
    }
    .nl .k { color: var(--muted); font-size: 12px; letter-spacing: 0.03em; text-transform: uppercase; }
    .nl .v { margin-top: 4px; color: var(--text); font-weight: 700; }
    .nl-list { margin: 8px 0 0; padding-left: 18px; color: var(--muted); }
    .nl-list li { margin: 6px 0; }
    .nl.collapsible { position: relative; padding-right: 34px; }
    .nl-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .nl-toggle { border: none; background: none; color: var(--muted); cursor: pointer; font-weight: 700; font-size: 12px; padding: 2px 6px; }
    .nl-toggle:hover { color: var(--accent); }
    .nl.collapsed .nl-list { display: none; }
    details.nl-raw summary { cursor: pointer; color: var(--muted); }
    details.nl-raw { margin-top: 10px; }

    /* -------------------- Guided Tour -------------------- */
    .tour-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      z-index: 9999;
      display: none;
    }
    .tour-overlay.active { display: block; }
    .tour-card {
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: min(420px, calc(100vw - 36px));
      background: rgba(13, 21, 43, 0.92);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.55);
      padding: 14px;
      backdrop-filter: blur(10px);
    }
    .tour-title { font-weight: 800; margin: 0 0 6px; }
    .tour-body { color: var(--muted); font-size: 14px; line-height: 1.4; }
    .tour-actions { display: flex; gap: 10px; margin-top: 12px; flex-wrap: wrap; }
    .tour-actions .pill-button { flex: 1; }
    .tour-mini {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.08);
      color: var(--muted);
      font-size: 12px;
      display: flex;
      gap: 10px;
      justify-content: space-between;
      align-items: center;
    }
    .tour-toggle {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      user-select: none;
    }
    .tour-toggle input { width: auto; }
    .tour-highlight {
      outline: 3px solid rgba(76, 240, 181, 0.9);
      outline-offset: 3px;
      border-radius: 12px;
      box-shadow: 0 0 0 8px rgba(76, 240, 181, 0.14);
      animation: tourPulse 1.3s ease-in-out infinite;
    }
    @keyframes tourPulse {
      0% { box-shadow: 0 0 0 8px rgba(76, 240, 181, 0.14); }
      50% { box-shadow: 0 0 0 14px rgba(76, 240, 181, 0.07); }
      100% { box-shadow: 0 0 0 8px rgba(76, 240, 181, 0.14); }
    }

    /* -------------------- Graph Viz -------------------- */
    canvas.graph-viz {
      width: 100%;
      height: 360px;
      display: block;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: radial-gradient(circle at 30% 30%, rgba(76, 240, 181, 0.08), transparent 45%),
                  radial-gradient(circle at 70% 20%, rgba(76, 150, 240, 0.08), transparent 45%),
                  rgba(13, 21, 43, 0.55);
    }
    .graph-viz-tip {
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
    .graph-viz-legend {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      color: var(--muted);
      font-size: 12px;
    }
    .graph-viz-legend .swatch {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display: inline-block;
      margin-right: 6px;
      border: 1px solid rgba(255,255,255,0.18);
    }

    /* -------------------- 3D Formation -------------------- */
    #formation-viz {
      position: relative;
      width: 100%;
      height: 260px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      background: radial-gradient(circle at 30% 20%, rgba(76, 240, 181, 0.06), transparent 40%),
                  radial-gradient(circle at 70% 10%, rgba(76, 150, 240, 0.05), transparent 40%),
                  rgba(255,255,255,0.02);
      overflow: hidden;
    }
    #formation-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border-radius: 12px;
      display: block;
      z-index: 1;
    }
    #formation-3d-container {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
      z-index: 2;
    }
    #formation-3d-status {
      position: absolute;
      top: 10px;
      left: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(11,18,36,0.75);
      color: var(--muted);
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
      z-index: 2;
    }
    #joint-formation-viz {
      position: relative;
      width: 100%;
      height: 460px;
      min-height: 420px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      overflow: hidden;
      margin-top: 10px;
      background: rgba(13,21,43,0.8);
    }
    #joint-formation-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <header>
    <div style="display:flex;align-items:center;gap:10px;">
      <div style="width:10px;height:10px;border-radius:50%;background:var(--accent);"></div>
      <strong>Helios C2 Demo</strong>
      <span class="pill">In-process | Simulated infra</span>
      <button class="pill-button" id="demo-toggle" title="Toggle realistic demo data">Demo Data: On</button>
      <button class="pill-button" id="tour-start" title="Guided tour">Guided Tour</button>
    </div>
    <nav>
      <a href="#dashboard" id="nav-dashboard" class="active">Overview</a>
      <a href="#approvals" id="nav-approvals">Review</a>
      <a href="#modules" id="nav-modules">Sensors</a>
      <a href="#intel" id="nav-intel">Investigate</a>
      <a href="#infrastructure" id="nav-infrastructure">Respond</a>
      <a href="#audit" id="nav-audit">Activity</a>
      <a href="#data" id="nav-data">Live Feed</a>
      <a href="#joint" id="nav-joint">Joint Ops</a>
    </nav>
  </header>

  <main class="container">
    <div id="dashboard" class="page">
      <div class="hero">
        <h1>Overview</h1>
        <p class="muted">A simple at-a-glance view of what the system is doing and how fast it’s running.</p>
        <span class="badge badge-live">Implemented</span>
        <div class="info-row">
          <div class="info-card">
            <div class="title">Start Here</div>
            <div class="body">Run a scenario, then come back to see new activity and recommendations update automatically.</div>
          </div>
          <div class="info-card">
            <div class="title">What You’re Seeing</div>
            <div class="body">Counts and timings from the last few runs. This page is meant to be quick and readable.</div>
          </div>
        </div>
      </div>
      <div class="kpi-row" id="dashboard-kpis"></div>
      <div class="grid">
        <div class="card" id="card-counters">
          <h3>What’s happening</h3>
          <table class="table" id="metrics-counters"></table>
        </div>
        <div class="card" id="card-timings">
          <h3>Where time is spent</h3>
          <table class="table" id="metrics-timings"></table>
        </div>
        <div class="card" id="card-metrics-explain">
          <h3>Metrics explained</h3>
          <div class="muted">Clear definitions, units, and how to interpret what you’re seeing.</div>
          <div id="metrics-explain" style="margin-top:10px;">Loading…</div>
        </div>
      </div>
      <div class="panel">
        <div class="status-row"><strong>Source</strong><span class="muted small">pipeline.export.metrics.path</span></div>
        <div class="status-row"><strong>Refresh</strong><span class="muted small">Every 5s</span></div>
        <div class="status-row"><strong>How to read</strong><span class="muted small">Counts go up as the system runs; timings are seconds (lower is faster).</span></div>
      </div>
    </div>

    <div id="approvals" class="page" style="display:none;">
      <div class="hero">
        <h1>Review & Approve</h1>
        <p class="muted">Who can approve what, and what needs a second look before action is taken.</p>
        <span class="badge badge-live">Implemented</span>
        <div class="info-row">
          <div class="info-card">
            <div class="title">What To Do</div>
            <div class="body">Use this when you want stricter review for higher-impact actions.</div>
          </div>
          <div class="info-card">
            <div class="title">Tip</div>
            <div class="body">Pair this with the Safety page to rate-limit or hold risky actions during spikes.</div>
          </div>
        </div>
      </div>
      <div id="approvals-content" class="grid"></div>
    </div>

    <!-- Guardrails page retained for future surfacing; hidden from nav and tour. -->
    <!--
    <div id="guardrails" class="page" style="display:none;">
      <div class="hero">
        <h1>Safety Controls</h1>
        <p class="muted">Limits and safety checks that help prevent overreaction and keep actions proportional.</p>
        <span class="badge badge-live">Implemented</span>
        <div class="info-row">
          <div class="info-card">
            <div class="title">What This Prevents</div>
            <div class="body">Too many actions too fast, repeated actions on the same asset, or bursts during noisy periods.</div>
          </div>
          <div class="info-card">
            <div class="title">How It Shows Up</div>
            <div class="body">If actions are limited, you’ll see fewer “Approved” actions and more items held for review.</div>
          </div>
        </div>
      </div>
      <div class="grid" id="guardrails-cards"></div>
    </div>
    -->

    <div id="modules" class="page" style="display:none;">
      <div class="hero">
        <h1>Sensors & Analytics</h1>
        <p class="muted">What sources are enabled and what they produce (video/audio/thermal analytics).</p>
        <span class="badge badge-live">Implemented</span>
        <div class="info-row">
          <div class="info-card">
            <div class="title">What To Do</div>
            <div class="body">Pick a sensor type to see what’s enabled and what the system will try to detect.</div>
          </div>
          <div class="info-card">
            <div class="title">Tip</div>
            <div class="body">After a run, come back here to see a quick summary of what was detected.</div>
          </div>
        </div>
      </div>
      <div class="panel">
        <div class="toolbar" id="module-nav"></div>
      </div>
      <div class="grid" id="modules-config"></div>
      <div class="card" id="module-details"></div>
      <div class="panel">
        <div class="status-row"><strong>Last ingest run</strong><span class="muted small" id="modules-run-meta">Waiting for audit...</span></div>
        <div id="modules-run-stats" class="muted">No run recorded yet. Run the pipeline with media ingest enabled to see results here.</div>
        <details class="nl-raw"><summary>Raw JSON (advanced)</summary><pre id="modules-run-stats-raw">—</pre></details>
      </div>
    </div>

    <div id="intel" class="page" style="display:none;">
      <div class="hero">
        <h1>Investigations</h1>
        <p class="muted">Tools to organize observations, build a case, and review supporting artifacts.</p>
        <span class="badge badge-live">Implemented</span>
        <div class="info-row">
          <div class="info-card">
            <div class="title">Entity Profiles</div>
            <div class="body">Summaries of observed tracks over time (non-identifying). Useful for pattern-of-life style review.</div>
          </div>
          <div class="info-card">
            <div class="title">Casebook</div>
            <div class="body">Keep notes, evidence, and hypotheses in one place so you can brief others quickly.</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="toolbar" id="intel-nav"></div>
      </div>

      <div id="intel-entity" class="grid"></div>
      <div id="intel-casebook" class="grid" style="display:none;"></div>
      <div id="intel-enhance" class="grid" style="display:none;"></div>
      <div id="intel-graph" class="grid" style="display:none;"></div>
    </div>

    <div id="infrastructure" class="page" style="display:none;">
      <div class="hero">
        <h1>Response Actions</h1>
        <p class="muted">How recommended actions would be sent to downstream systems. This demo uses local files and a mock trigger.</p>
        <span class="badge badge-mock">Mock HTTP trigger</span>
      </div>
      <div class="grid">
        <div class="card">
          <h3>File Export</h3>
          <p class="muted">Writes infrastructure actions to JSONL at configured path.</p>
          <div class="status-row"><span>Status</span><span class="badge badge-live">Implemented</span></div>
          <div id="infra-file-status" class="muted">Loading...</div>
          <details class="nl-raw"><summary>Raw JSON (advanced)</summary><pre id="infra-file-status-raw">—</pre></details>
        </div>
        <div class="card">
          <h3>HTTP Forward (Mock)</h3>
          <p class="muted">Sends the last actions payload to a mock endpoint and records success/failure locally.</p>
          <div class="status-row"><span>Status</span><span class="badge badge-mock">Mocked</span></div>
          <button id="mock-send">Send Mock Payload</button>
          <div id="mock-result" class="muted">No send yet.</div>
        </div>
      </div>
    </div>

    <div id="data" class="page" style="display:none;">
      <div class="hero">
        <h1>Live Feed</h1>
        <p class="muted">The latest events, recommended actions, and a short activity stream from the most recent run.</p>
        <span class="badge badge-live">Implemented</span>
        <div class="info-row">
          <div class="info-card">
            <div class="title">What To Do</div>
            <div class="body">Check recommendations, then approve/deny the suggested course of action with a short rationale.</div>
          </div>
          <div class="info-card">
            <div class="title">What This Means</div>
            <div class="body">“Events” describe what was detected. “Actions” are suggested responses that may require review.</div>
          </div>
        </div>
      </div>
      <div class="grid">
        <div class="card">
          <h3>What was detected</h3>
          <p class="muted">Recent events and recommended actions.</p>
          <div class="status-row"><span>Events</span><span class="muted small" id="events-count">0</span></div>
          <div class="status-row"><span>Tasks</span><span class="muted small" id="tasks-count">0</span></div>
          <ul class="list scroll" id="events-preview">Waiting for data...</ul>
        </div>
        <div class="card">
          <h3>Formation live view</h3>
          <p class="muted">Animate autonomous vehicles into selected formations. Voice or typed commands trigger the movement.</p>
          <div class="status-row"><span>Status</span><span class="badge badge-mock" id="formation-badge">Simulated</span></div>
          <div class="status-row"><span class="small">Source</span><span id="formation-source" class="muted small">Demo seed</span></div>
          <div class="status-row"><span class="small">Formation</span>
            <select id="formation-select"></select>
          </div>
          <div class="toolbar" style="flex-wrap:wrap;gap:8px;">
            <button class="pill-button" id="formation-apply">Apply Formation</button>
            <button class="pill-button" id="formation-reset">Reset</button>
            <button class="pill-button" id="voice-start">Start Voice</button>
            <button class="pill-button" id="voice-stop">Stop Voice</button>
          </div>
          <div class="nl collapsible collapsed" id="formation-legend">
            <div class="nl-header">
              <div class="k">Voice commands</div>
              <button class="nl-toggle" id="formation-legend-toggle" aria-expanded="false" title="Show voice commands" type="button">▼</button>
            </div>
            <ul class="nl-list" id="formation-legend-list">
              <li class="muted small">Loading compatible phrases…</li>
            </ul>
          </div>
          <div class="status-row"><span class="small">Heard</span><span id="formation-voice-status" class="muted small">Idle</span></div>
          <div class="status-row"><span class="small">State</span><span id="formation-state" class="muted small">Waiting</span></div>
          <div id="formation-viz">
            <canvas id="formation-canvas"></canvas>
            <div id="formation-3d-container" aria-label="3D formation view">
              <div id="formation-3d-status" class="muted small">Initializing 3D view…</div>
            </div>
          </div>
          <div class="status-row" style="margin-top:8px;"><span class="small">Formation vehicles</span><span class="muted small" id="formation-vehicle-count">0</span></div>
          <ul class="list scroll" id="formation-vehicles" style="max-height:120px;">No vehicles yet.</ul>
        </div>
        <div class="card">
          <h3>Activity stream</h3>
          <p class="muted">A short timeline of what the system just did.</p>
          <div class="status-row"><span>Status</span><span class="badge badge-live">Implemented</span></div>
          <ul class="list scroll" id="audit-preview">Waiting for data...</ul>
        </div>
        <div class="card">
          <h3>Commander intent</h3>
          <p class="muted">Latest stated intent captured from text/voice or seeded config.</p>
          <div class="status-row"><span>Status</span><span class="badge badge-live">Implemented</span></div>
          <ul class="list scroll" id="intents-preview">Waiting for data...</ul>
        </div>
        <div class="card collapsible-card" id="playbook-card">
          <div class="card-head">
            <div>
              <h3 style="margin:0;">Playbook & platform commands</h3>
              <p class="muted" style="margin:4px 0 0;">Mapped playbook actions and queued platform commands with send status.</p>
            </div>
            <button class="card-toggle" id="playbook-toggle" aria-expanded="true" title="Collapse playbook card" type="button">▼</button>
          </div>
          <div class="collapsible-body" id="playbook-body">
            <div class="status-row"><span>Status</span><span class="badge badge-live">Implemented</span></div>
            <ul class="list scroll" id="playbook-preview">Waiting for data...</ul>
            <ul class="list scroll" id="platform-preview">Waiting for data...</ul>
          </div>
        </div>
        <div class="card">
          <h3>Command vehicles</h3>
          <p class="muted">Air/Land/Sea/Space assets with link health, battery, and queued actions.</p>
          <div class="status-row"><span>Status</span><span class="badge badge-live">Implemented</span></div>
          <ul class="list scroll" id="assets-preview">Waiting for assets...</ul>
          <div class="nl">
            <div class="k">Send command</div>
            <div class="v small">Type a verbal instruction and target a vehicle. POSTs to /api/platform_commands; falls back to local queue if offline.</div>
          </div>
          <div class="status-row wrap"><span class="small">Event (optional)</span><select id="asset-event-select"></select></div>
          <div class="status-row wrap"><span class="small">Vehicle / Asset</span><select id="asset-select"></select></div>
          <div class="status-row"><span class="small">Domain (auto if asset)</span><input type="text" id="asset-domain-input" placeholder="air / land / sea / space" /></div>
          <div class="status-row"><span class="small">Command (verbal)</span></div>
          <textarea id="asset-command-input" placeholder="e.g., Raven-Alpha hold over Line Bravo and watch loading bay"></textarea>
          <button class="pill-button" id="asset-send-btn">Send Command</button>
          <div id="asset-queue-status" class="muted small">No command sent yet.</div>
        </div>
        <div class="card">
          <h3>Recommendation</h3>
          <p class="muted">A short plain-language recommendation. Approve or deny with a brief reason.</p>
          <div class="status-row"><span>Status</span><span class="badge badge-live" id="action-status">—</span></div>
          <ul class="list scroll" id="action-preview">Loading...</ul>
          <div class="status-row"><span class="small">Actor</span><input type="text" id="action-actor" placeholder="approver id" />
          </div>
          <div class="status-row"><span class="small">Token</span><input type="text" id="action-token" placeholder="signing secret" /></div>
          <div class="status-row"><span class="small">Rationale</span></div>
          <textarea id="action-rationale" placeholder="why approve/deny"></textarea>
          <div style="display:flex;gap:10px;margin-top:10px;">
            <button class="pill-button" id="action-approve">Approve</button>
            <button class="pill-button" id="action-deny">Deny</button>
          </div>
        </div>
      </div>
    </div>

    <div id="joint" class="page" style="display:none;">
      <div class="hero">
        <h1>Joint Ops</h1>
        <p class="muted">Unified air, land, and sea formations aligned to a shared objective. This view prioritizes coordinated movement and intent.</p>
        <span class="badge badge-live">Simulated</span>
        <div class="info-row">
          <div class="info-card">
            <div class="title">Shared objective</div>
            <div class="body" id="joint-objective">Coordinate air support, ground incursion, and undersea support to secure the objective.</div>
          </div>
          <div class="info-card">
            <div class="title">Domain units</div>
            <div class="body">Air: <span id="joint-air-count">0</span> · Land: <span id="joint-land-count">0</span> · Sea: <span id="joint-sea-count">0</span></div>
          </div>
        </div>
      </div>
      <div class="grid">
        <div class="card" style="grid-column: 1 / -1;">
          <h3>Multi-domain formation view</h3>
          <p class="muted">Simulated autonomous vehicles move in coordinated formations across domains. Voice or typed objectives steer the formation.</p>
          <div class="status-row"><span>Status</span><span class="badge badge-mock" id="joint-formation-badge">Simulated</span></div>
          <div class="status-row"><span class="small">Source</span><span id="joint-formation-source" class="muted small">Demo seed</span></div>
          <div class="status-row"><span class="small">Formation</span>
            <select id="joint-formation-select"></select>
          </div>
          <div class="toolbar" style="flex-wrap:wrap;gap:8px;">
            <button class="pill-button" id="joint-formation-apply">Apply Formation</button>
            <button class="pill-button" id="joint-formation-reset">Reset</button>
            <button class="pill-button" id="joint-voice-start">Start Voice</button>
            <button class="pill-button" id="joint-voice-stop">Stop Voice</button>
          </div>
          <div class="nl collapsible collapsed" id="joint-formation-legend">
            <div class="nl-header">
              <div class="k">Objective voice commands</div>
              <button class="nl-toggle" id="joint-formation-legend-toggle" aria-expanded="false" title="Show voice commands" type="button">▼</button>
            </div>
            <ul class="nl-list" id="joint-formation-legend-list">
              <li class="muted small">Loading compatible phrases…</li>
            </ul>
          </div>
          <div class="status-row"><span class="small">Heard</span><span id="joint-formation-voice-status" class="muted small">Idle</span></div>
          <div class="status-row"><span class="small">State</span><span id="joint-formation-state" class="muted small">Waiting</span></div>
          <div id="joint-formation-viz">
            <canvas id="joint-formation-canvas"></canvas>
          </div>
          <div class="status-row" style="margin-top:8px;"><span class="small">Formation vehicles</span><span class="muted small" id="joint-formation-vehicle-count">0</span></div>
          <ul class="list scroll" id="joint-formation-vehicles" style="max-height:140px;">No vehicles yet.</ul>
        </div>
        <div class="card">
          <h3>Joint command console</h3>
          <p class="muted">Broadcast a shared objective across air, land, and sea assets. Commands are sent to the platform queue.</p>
          <div class="status-row wrap"><span class="small">Focus domain</span>
            <select id="joint-domain-select">
              <option value="multi">multi</option>
              <option value="air">air</option>
              <option value="land">land</option>
              <option value="sea">sea</option>
            </select>
          </div>
          <div class="status-row"><span class="small">Objective / Command</span></div>
          <textarea id="joint-command-input" placeholder="e.g., capture this base and establish air support over Line Bravo"></textarea>
          <button class="pill-button" id="joint-command-send">Broadcast objective</button>
          <div id="joint-command-status" class="muted small">No joint command sent yet.</div>
        </div>
        <div class="card">
          <h3>Sample objectives (voice or text)</h3>
          <p class="muted">These phrases map to formations and shared objectives across domains.</p>
          <ul class="list" id="joint-sample-objectives">
            <li>Capture this base and establish air support over Line Bravo.</li>
            <li>Surround that target with a perimeter and hold the outer ring.</li>
            <li>Ground incursion through the corridor, air cover overhead.</li>
            <li>Undersea support along the trench while surface units screen the bay.</li>
            <li>Secure the harbor with sea line screening and air overwatch.</li>
          </ul>
        </div>
      </div>
    </div>

    <div id="audit" class="page" style="display:none;">
      <div class="hero">
        <h1>Activity Log</h1>
        <p class="muted">A detailed, append-only log of system activity for review and troubleshooting.</p>
        <span class="badge badge-live">Implemented</span>
        <div class="info-row">
          <div class="info-card">
            <div class="title">When To Use This</div>
            <div class="body">After a run, use this to understand why a recommendation was made and what checks were applied.</div>
          </div>
          <div class="info-card">
            <div class="title">Tip</div>
            <div class="body">If something looks wrong, refresh and increase the tail to see more context.</div>
          </div>
        </div>
      </div>
      <div class="panel">
        <div class="toolbar">
          <span class="muted small">Tail</span>
          <input type="number" id="audit-tail" value="120" min="20" max="2000" />
          <button class="pill-button" id="audit-refresh">Refresh</button>
          <button class="pill-button" id="audit-download">Download JSON</button>
        </div>
      </div>
      <div class="grid" id="audit-summaries"></div>
      <div class="card" style="overflow:auto;">
        <table class="table" id="audit-table"></table>
      </div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <script>
    const navLinks = document.querySelectorAll('nav a');
    const pages = document.querySelectorAll('.page');

    function showPage(rawHash) {
      const fallback = '#dashboard';
      const hash = rawHash || fallback;
      const target = hash.startsWith('#') ? hash : `#${hash}`;
      const pageId = target.slice(1) || 'dashboard';
      let found = false;

      pages.forEach(p => {
        const isMatch = p.id === pageId;
        p.style.display = isMatch ? 'block' : 'none';
        if (isMatch) found = true;
      });

      navLinks.forEach(n => {
        const href = n.getAttribute('href');
        if (href === target) {
          n.classList.add('active');
        } else {
          n.classList.remove('active');
        }
      });

      if (!found && pageId !== 'dashboard') {
        return showPage(fallback);
      }

      if (window.location.hash !== target) {
        window.location.hash = target;
      }

      if (pageId === 'dashboard' || pageId === 'data') {
        refreshFormationViz();
      }
      if (pageId === 'joint') {
        refreshFormationVizJoint();
      }
    }

    navLinks.forEach(link => {
      link.addEventListener('click', e => {
        e.preventDefault();
        const target = link.getAttribute('href') || '#dashboard';
        showPage(target);
        if (target === '#intel') {
          initIntelUI();
          loadIntelSelected();
        }
      });
    });

    window.addEventListener('hashchange', () => {
      const hash = window.location.hash || '#dashboard';
      showPage(hash);
      if (hash === '#intel') {
        initIntelUI();
        loadIntelSelected();
      }
    });

    const initialHash = window.location.hash || '#dashboard';
    showPage(initialHash);
    if (initialHash === '#intel') {
      initIntelUI();
      loadIntelSelected();
    }
    const playbookCard = document.getElementById('playbook-card');
    const playbookToggle = document.getElementById('playbook-toggle');
    if (playbookCard && playbookToggle) {
      playbookToggle.addEventListener('click', () => {
        const isCollapsed = playbookCard.classList.toggle('collapsed');
        playbookToggle.textContent = isCollapsed ? '▶' : '▼';
        playbookToggle.setAttribute('aria-expanded', (!isCollapsed).toString());
        playbookToggle.setAttribute('title', isCollapsed ? 'Expand playbook card' : 'Collapse playbook card');
      });
    }
    const moduleCatalog = {
      vision: { title: 'Vision', desc: 'Detections, tracks, action recognition, ALPR, optional gait embeddings.', outputs: ['Detections', 'Tracks/ReID', 'ALPR', 'Actions'] },
      audio: { title: 'Audio', desc: 'Sound event detection and quick ASR transcript.', outputs: ['Sound events', 'Transcript'] },
      thermal: { title: 'Thermal', desc: 'Thermal anomaly scan and hotspot ratios.', outputs: ['Thermal frames', 'Hotspot ratios'] },
      gait: { title: 'Gait', desc: 'Gait embeddings piggybacked on vision detections.', outputs: ['Gait embeddings'] },
      scene: { title: 'Scene Fusion', desc: 'Scene graph fused from tracks, plates, and segments.', outputs: ['Scene graph'] },
    };

    let latestAudit = [];
    let latestEvents = [];
    let latestTasks = [];
    let latestAssets = [];
    let latestCommands = [];
    let latestAssetsSource = 'demo';
    let localQueuedCommands = [];
    let formationLegendCollapsed = true;
    let jointFormationLegendCollapsed = true;
    const formationLibrary = {
      line: [[-1, 0], [-0.6, 0], [-0.2, 0], [0.2, 0], [0.6, 0], [1, 0]],
      column: [[0, -1], [0, -0.6], [0, -0.2], [0, 0.2], [0, 0.6], [0, 1]],
      wedge: [[0, -0.2], [-0.5, -0.2], [0.5, -0.2], [-0.8, 0.3], [0.8, 0.3], [0, 0.5]],
      delta: [[0, -0.9], [-0.6, 0.3], [0.6, 0.3], [-0.9, 0.9], [0, 0.6], [0.9, 0.9]],
      box: [[-0.8, -0.8], [0.8, -0.8], [-0.8, 0.8], [0.8, 0.8], [0, -0.2], [0, 0.2]],
      echelon_left: [[-0.9, -0.9], [-0.6, -0.6], [-0.3, -0.3], [0, 0], [0.3, 0.3], [0.6, 0.6]],
      echelon_right: [[0.9, -0.9], [0.6, -0.6], [0.3, -0.3], [0, 0], [-0.3, 0.3], [-0.6, 0.6]],
    };
    const formationSim = {
      canvas: null,
      ctx: null,
      vehicles: [],
      targets: [],
      running: false,
      formation: '',
      raf: null,
      voiceRecognition: null,
      voiceActive: false,
      lastHeard: '',
    };
    const formationSimJoint = {
      canvas: null,
      ctx: null,
      vehicles: [],
      targets: [],
      running: false,
      formation: '',
      raf: null,
      voiceRecognition: null,
      voiceActive: false,
      lastHeard: '',
    };
    const formationPalette = {
      air: { fill: '#7ae3ff', stroke: '#1ba3d6', highlight: '#c7f4ff', shadow: 'rgba(0, 53, 92, 0.45)' },
      land: { fill: '#b5c06c', stroke: '#7a8637', highlight: '#e6efad', shadow: 'rgba(38, 46, 6, 0.5)' },
      sea: { fill: '#6bb0ff', stroke: '#2f6bb8', highlight: '#b9d8ff', shadow: 'rgba(7, 28, 66, 0.5)' },
      space: { fill: '#d7b3ff', stroke: '#7a4ad6', highlight: '#f1e5ff', shadow: 'rgba(50, 8, 92, 0.55)' },
      multi: { fill: '#4cf0b5', stroke: '#24a976', highlight: '#a8ffd8', shadow: 'rgba(4, 52, 35, 0.55)' },
    };
    const formationVoiceLegend = {
      box: [
        'box formation over line alpha',
        'square up around the depot',
        'form a box perimeter at the gate',
      ],
      delta: [
        'delta formation over line bravo',
        'tight delta at the loading bay',
        'delta stack on axis charlie',
      ],
      wedge: [
        'wide wedge over the bay',
        'vee formation on point alpha',
        'push a wedge forward',
      ],
      echelon_left: [
        'echelon left along the ridge',
        'left echelon stepping down the slope',
        'left stagger over line charlie',
      ],
      echelon_right: [
        'echelon right along the ridge',
        'right echelon stepping down the slope',
        'right stagger over line bravo',
      ],
      column: [
        'column through the corridor',
        'line astern on route bravo',
        'stack trail behind lead',
      ],
      line: [
        'line abreast along line alpha',
        'hold a straight line facing north',
        'line formation across the bay',
      ],
    };
    const formationVoiceLegendJoint = {
      box: [
        'surround that target',
        'box in the objective',
        'form a perimeter around the base',
      ],
      delta: [
        'capture this base',
        'secure the compound',
        'take the strongpoint',
      ],
      wedge: [
        'establish air support',
        'air support spearhead',
        'air wedge over the base',
      ],
      column: [
        'ground incursion through the corridor',
        'push a ground column to the base',
        'advance in column',
      ],
      line: [
        'undersea support along the trench',
        'sea line screening the harbor',
        'hold a line offshore',
      ],
      echelon_left: [
        'left screen the approach',
        'left staggered perimeter',
        'left flank guard',
      ],
      echelon_right: [
        'right screen the approach',
        'right staggered perimeter',
        'right flank guard',
      ],
    };
    let threeModulePromise = null;
    const scriptCache = new Map();
    const formation3d = {
      ready: false,
      renderer: null,
      scene: null,
      camera: null,
      controls: null,
      meshes: [],
      targets: [],
      formation: 'line',
      anim: null,
      mod: null,
      container: null,
    };
    let modulesCfgCache = { modules: {}, media: {}, ingest: {} };
    let moduleStatsCache = null;
    let selectedModule = 'vision';
    let guardrailCfgCache = null;

    const formationPersistKey = 'helios_formation_overlay';
    const formationPersistKeyJoint = 'helios_formation_joint_overlay';
    const formationCameraKey = 'helios_formation_camera';

    function loadPersistedFormation() {
      try {
        const raw = localStorage.getItem(formationPersistKey);
        if (!raw) return null;
        const data = JSON.parse(raw);
        if (!data || typeof data !== 'object') return null;
        if (typeof data.formation !== 'string') return null;
        if (!Array.isArray(data.normTargets)) return null;
        return data;
      } catch (_) {
        return null;
      }
    }

    function loadPersistedFormationJoint() {
      try {
        const raw = localStorage.getItem(formationPersistKeyJoint);
        if (!raw) return null;
        const data = JSON.parse(raw);
        if (!data || typeof data !== 'object') return null;
        if (typeof data.formation !== 'string') return null;
        if (!Array.isArray(data.normTargets)) return null;
        return data;
      } catch (_) {
        return null;
      }
    }

    function persistFormationState(formation, normTargets) {
      if (!formation || !Array.isArray(normTargets)) return;
      try {
        const payload = { formation, normTargets };
        localStorage.setItem(formationPersistKey, JSON.stringify(payload));
      } catch (_) {}
    }

    function persistFormationStateJoint(formation, normTargets) {
      if (!formation || !Array.isArray(normTargets)) return;
      try {
        const payload = { formation, normTargets };
        localStorage.setItem(formationPersistKeyJoint, JSON.stringify(payload));
      } catch (_) {}
    }

    function loadPersistedCamera() {
      try {
        const raw = localStorage.getItem(formationCameraKey);
        if (!raw) return null;
        const data = JSON.parse(raw);
        if (!data || typeof data !== 'object') return null;
        const { pos, target } = data;
        if (!pos || typeof pos.x !== 'number' || typeof pos.y !== 'number' || typeof pos.z !== 'number') return null;
        if (!target || typeof target.x !== 'number' || typeof target.y !== 'number' || typeof target.z !== 'number') return null;
        return { pos, target };
      } catch (_) {
        return null;
      }
    }

    function persistFormationCamera(camera, controls) {
      if (!camera || !controls || !controls.target) return;
      try {
        const payload = {
          pos: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
          target: { x: controls.target.x, y: controls.target.y, z: controls.target.z },
        };
        localStorage.setItem(formationCameraKey, JSON.stringify(payload));
      } catch (_) {}
    }

    function reuseNormalizedTargets(formation, count) {
      const persisted = loadPersistedFormation();
      if (!persisted || persisted.formation !== formation || !Array.isArray(persisted.normTargets)) return null;
      const src = persisted.normTargets.filter(p => p && typeof p.nx === 'number' && typeof p.ny === 'number');
      if (!src.length) return null;
      if (src.length === count) return src.slice();
      const out = [];
      for (let i = 0; i < count; i++) out.push(src[i % src.length]);
      return out;
    }

    function reuseNormalizedTargetsJoint(formation, count) {
      const persisted = loadPersistedFormationJoint();
      if (!persisted || persisted.formation !== formation || !Array.isArray(persisted.normTargets)) return null;
      const src = persisted.normTargets.filter(p => p && typeof p.nx === 'number' && typeof p.ny === 'number');
      if (!src.length) return null;
      if (src.length === count) return src.slice();
      const out = [];
      for (let i = 0; i < count; i++) out.push(src[i % src.length]);
      return out;
    }

    async function loadScriptOnce(src) {
      if (scriptCache.has(src)) return scriptCache.get(src);
      const p = new Promise((resolve, reject) => {
        const el = document.createElement('script');
        el.src = src;
        el.async = true;
        el.onload = () => resolve(true);
        el.onerror = (e) => reject(e);
        document.head.appendChild(el);
      }).catch((err) => {
        console.warn('Script load failed', src, err);
        return null;
      });
      scriptCache.set(src, p);
      return p;
    }

    function updateFormation3DStatus(text) {
      let el = document.getElementById('formation-3d-status');
      if (!el) {
        const container = document.getElementById('formation-3d-container');
        el = document.createElement('div');
        el.id = 'formation-3d-status';
        el.className = 'muted small';
        if (container) container.appendChild(el);
      }
      if (el) el.textContent = text;
    }

    async function loadThreeModule() {
      if (formation3d.mod) return formation3d.mod;
      if (!threeModulePromise) {
        updateFormation3DStatus('Loading 3D renderer…');
        threeModulePromise = (async () => {
          try {
            const THREE = await import('https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js');
            let controlsMod = null;
            try {
              controlsMod = await import('https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/controls/OrbitControls.js');
            } catch (err) {
              console.warn('OrbitControls module load failed; will attempt global fallback', err);
            }
            const OrbitControls = controlsMod ? controlsMod.OrbitControls : (THREE.OrbitControls || null);
            return { THREE, OrbitControls };
          } catch (err) {
            console.warn('three module import failed, trying global build', err);
            const ok = await loadScriptOnce('https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js');
            if (!ok || !window.THREE) throw err;
            await loadScriptOnce('https://cdn.jsdelivr.net/npm/three@0.160.1/examples/js/controls/OrbitControls.js');
            const OrbitControls = window.THREE?.OrbitControls || window.OrbitControls || null;
            return { THREE: window.THREE, OrbitControls };
          }
        })().catch((err) => {
          console.warn('three.js load failed', err);
          return null;
        });
      }
      formation3d.mod = await threeModulePromise;
      if (!formation3d.mod) updateFormation3DStatus('3D renderer unavailable');
      return formation3d.mod;
    }

    function hexToThreeColor(hex, THREE) {
      if (!hex || !THREE) return new THREE.Color(0x4cf0b5);
      const norm = hex.startsWith('#') ? hex.slice(1) : hex;
      return new THREE.Color(parseInt(norm, 16));
    }

    function makeVehicleMesh(mod, asset) {
      const { THREE } = mod;
      const palette = pickPalette(asset?.domain || 'multi');
      const color = hexToThreeColor(palette.fill, THREE);
      let geometry;
      const domain = (asset?.domain || '').toLowerCase();
      if (domain === 'air') {
        geometry = new THREE.ConeGeometry(6, 18, 12);
      } else if (domain === 'land') {
        geometry = new THREE.BoxGeometry(14, 6, 10);
      } else if (domain === 'sea') {
        geometry = new THREE.CylinderGeometry(5, 8, 14, 10, 1, false);
      } else if (domain === 'space') {
        geometry = new THREE.OctahedronGeometry(8, 0);
      } else {
        geometry = new THREE.DodecahedronGeometry(7);
      }
      const material = new THREE.MeshStandardMaterial({
        color,
        emissive: color,
        emissiveIntensity: 0.12,
        metalness: 0.2,
        roughness: 0.48,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = false;
      mesh.receiveShadow = false;
      mesh.rotation.order = 'YXZ';
      mesh.userData.assetId = asset?.id || null;
      return mesh;
    }

    function formationTargets3D(name, count, assets, normTargets) {
      const pts = normTargets && normTargets.length ? normTargets : formationTargetsNormalized(name, count);
      const scale = 140;
      const targets = [];
      for (let i = 0; i < count; i++) {
        const base = pts[i % pts.length];
        const asset = assets && assets.length ? assets[i % assets.length] : null;
        const alt = asset?.route?.[0]?.alt_m ?? asset?.alt_m ?? (asset?.domain === 'air' ? 60 : 12);
        const y = Math.max(6, Math.min(alt * 0.6, 140));
        // Map normalized 0..1 into centered world coords (-scale..+scale).
        const cx = (base.nx ?? 0.5) * 2 - 1;
        const cz = (base.ny ?? 0.5) * 2 - 1;
        targets.push({
          x: cx * scale,
          y,
          z: cz * scale,
        });
      }
      return targets;
    }

    function ensureFormation3DVehicles(count, assets) {
      if (!formation3d.ready || !formation3d.mod) return;
      const { THREE } = formation3d.mod;
      const needs = Math.max(count, 6);
      while (formation3d.meshes.length < needs) {
        const asset = assets && assets.length ? assets[formation3d.meshes.length % assets.length] : null;
        const mesh = makeVehicleMesh(formation3d.mod, asset);
        formation3d.scene.add(mesh);
        formation3d.meshes.push(mesh);
      }
      while (formation3d.meshes.length > needs) {
        const mesh = formation3d.meshes.pop();
        formation3d.scene.remove(mesh);
      }
      formation3d.meshes.forEach((mesh, idx) => {
        const asset = assets && assets.length ? assets[idx % assets.length] : null;
        if (!asset || !THREE) return;
        const palette = pickPalette(asset.domain);
        const color = hexToThreeColor(palette.fill, THREE);
        const mat = mesh.material;
        if (mat && mat.color) {
          mat.color = color.clone();
          mat.emissive = color.clone();
        }
      });
    }

    function resizeFormation3D() {
      if (!formation3d.ready || !formation3d.container || !formation3d.renderer || !formation3d.camera) return;
      const rect = formation3d.container.getBoundingClientRect();
      formation3d.renderer.setSize(rect.width, rect.height);
      formation3d.camera.aspect = rect.width / Math.max(1, rect.height);
      formation3d.camera.updateProjectionMatrix();
    }

    async function initFormation3D() {
      const container = document.getElementById('formation-3d-container');
      if (!container) return;
      const mod = await loadThreeModule();
      if (!mod) return;
      const { THREE, OrbitControls } = mod;
      const rect = container.getBoundingClientRect();
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(rect.width, rect.height);
      renderer.setClearColor(0x000000, 0);
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(55, rect.width / Math.max(1, rect.height), 0.1, 2000);
      camera.position.set(0, 110, 170);
      const controls = OrbitControls ? new OrbitControls(camera, renderer.domElement) : null;
      if (controls) {
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.target.set(0, 30, 0);
        controls.update();
      }
      const persistedCam = loadPersistedCamera();
      if (persistedCam) {
        camera.position.set(persistedCam.pos.x, persistedCam.pos.y, persistedCam.pos.z);
        if (controls) {
          controls.target.set(persistedCam.target.x, persistedCam.target.y, persistedCam.target.z);
          controls.update();
        }
      }
      scene.add(new THREE.HemisphereLight(0x9ab0d6, 0x0b1224, 0.7));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(120, 160, 80);
      scene.add(dir);
      const grid = new THREE.GridHelper(320, 16, 0x4cf0b5, 0x1c2948);
      grid.position.y = 0;
      scene.add(grid);
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(360, 360),
        new THREE.MeshStandardMaterial({ color: 0x0f162c, metalness: 0.1, roughness: 0.92, opacity: 0.92, transparent: true })
      );
      plane.rotation.x = -Math.PI / 2;
      plane.position.y = -0.2;
      plane.receiveShadow = false;
      scene.add(plane);

      const status = document.getElementById('formation-3d-status') || (() => {
        const badge = document.createElement('div');
        badge.id = 'formation-3d-status';
        badge.className = 'muted small';
        badge.textContent = '3D view ready';
        return badge;
      })();

      container.innerHTML = '';
      container.appendChild(renderer.domElement);
      container.appendChild(status);

      formation3d.ready = true;
      formation3d.renderer = renderer;
      formation3d.scene = scene;
      formation3d.camera = camera;
      formation3d.controls = controls;
      formation3d.container = container;
      formation3d.mod = mod;

      if (controls) {
        controls.addEventListener('change', () => persistFormationCamera(camera, controls));
      }

      resizeFormation3D();
      window.addEventListener('resize', () => {
        resizeFormation3D();
        syncFormationCanvasSize();
      });
      updateFormation3DStatus('3D view ready');
      ensureFormation3DVehicles(latestAssets.length || 6, latestAssets);
      setFormation3D(formationSim.formation || 'line', latestAssets);
    }

    function tickFormation3D() {
      if (!formation3d.ready || !formation3d.mod) return;
      const { THREE } = formation3d.mod;
      if (!formation3d.targets.length) {
        formation3d.targets = formationTargets3D(formation3d.formation || 'line', formation3d.meshes.length || 6, latestAssets);
      }
      let moving = false;
      formation3d.meshes.forEach((mesh, idx) => {
        const t = formation3d.targets[idx % formation3d.targets.length];
        if (!t) return;
        const target = new THREE.Vector3(t.x, t.y, t.z);
        mesh.position.lerp(target, 0.08);
        mesh.rotation.y += 0.01;
        if (mesh.position.distanceTo(target) > 0.6) moving = true;
      });
      if (formation3d.controls) formation3d.controls.update();
      formation3d.renderer.render(formation3d.scene, formation3d.camera);
      updateFormation3DStatus(moving ? `3D moving: ${formation3d.formation}` : `3D ready: ${formation3d.formation}`);
      formation3d.anim = requestAnimationFrame(tickFormation3D);
    }

    async function setFormation3D(name, assets, normTargets) {
      if (!formation3d.ready) await initFormation3D();
      if (!formation3d.ready) return;
      const normalized = formationLibrary[name] ? name : 'line';
      formation3d.formation = normalized;
      const count = Math.max(assets?.length || formationSim.vehicles.length || 6, 6);
      ensureFormation3DVehicles(count, assets);
      formation3d.targets = formationTargets3D(normalized, count, assets, normTargets);
      if (!formation3d.anim) formation3d.anim = requestAnimationFrame(tickFormation3D);
    }

    // -------------------- Demo Mode (seeded, realistic data) --------------------
    let demoMode = (localStorage.getItem('helios_demo_mode') ?? 'true') === 'true';

    function escapeHtml(val) {
      return String(val ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function updateDemoToggle() {
      const btn = document.getElementById('demo-toggle');
      if (!btn) return;
      btn.textContent = demoMode ? 'Demo Data: On' : 'Demo Data: Off';
      btn.style.boxShadow = demoMode ? '0 10px 30px rgba(76, 240, 181, 0.35)' : 'none';
      btn.style.opacity = demoMode ? '1' : '0.85';
    }

    function setDemoMode(on) {
      demoMode = Boolean(on);
      localStorage.setItem('helios_demo_mode', demoMode ? 'true' : 'false');
      updateDemoToggle();
      // Refresh everything so the UI is consistent.
      try { loadMetrics(); } catch (_) {}
      try { loadConfig(); } catch (_) {}
      try { loadEvents(); } catch (_) {}
      try { loadAudit(); } catch (_) {}
      try { loadIntelSelected(); } catch (_) {}
    }

    document.getElementById('demo-toggle')?.addEventListener('click', () => setDemoMode(!demoMode));
    updateDemoToggle();

    function demoId(prefix) {
      return `${prefix}-${Math.random().toString(16).slice(2, 10)}`;
    }

    function buildDemoState() {
      const nowMs = Date.now();
      const mkTs = (minsAgo) => nowMs - minsAgo * 60 * 1000;

      const cfg = {
        pipeline: {
          ingest: {
            mode: 'modules_media',
            media: { stride: 8, downscale: 1.0, max_frames: 180, source: 'scenario_infra.yaml' },
            modules: {
              enable_vision: true,
              enable_audio: true,
              enable_thermal: false,
              enable_gait: true,
              enable_scene: true,
            },
          },
          guardrails: {
            rate_limits: {
              per_domain: { facility: 6, access: 8, traffic: 4 },
              per_event: 3,
              total: 14,
              per_asset_infra: 2,
              per_asset_infra_patterns: { lock: 1, dispatch_patrol: 2 },
            },
            risk_budgets: {
              demo_tenant: { max_risk: 7.5, per_action: { lock: 1.0, dispatch_patrol: 1.5, notify: 0.3 } },
            },
            health_alert_drop_ratio: 0.35,
          },
          rbac: {
            action_requirements: {
              lock: { required_roles: ['security_lead'], min_approvals: 2 },
              dispatch_patrol: { required_roles: ['security_ops'], min_approvals: 1 },
              notify: { required_roles: ['analyst'], min_approvals: 0 },
            },
          },
          infrastructure: {
            action_defaults: {
              lock: { required_roles: ['security_ops'], min_approvals: 1 },
              dispatch_patrol: { required_roles: ['security_ops'], min_approvals: 1 },
              notify: { required_roles: ['analyst'], min_approvals: 0 },
            },
          },
          export: {
            infrastructure: {
              path: 'out/infrastructure_actions.jsonl',
              rotate_max_bytes: 1048576,
              http: { enabled: false },
            },
          },
        },
      };

      const events = [
        {
          id: 'ev-0001',
          ts_ms: mkTs(6),
          category: 'perimeter_anomaly',
          domain: 'facility',
          severity: 3,
          severity_label: 'warning',
          status: 'open',
          summary: 'Unusual movement near the north fence line (after-hours)',
          entities: ['ent-01'],
          sources: ['camera:north-fence'],
        },
        {
          id: 'ev-0002',
          ts_ms: mkTs(10),
          category: 'possible_tailgating',
          domain: 'access',
          severity: 2,
          severity_label: 'notice',
          status: 'open',
          summary: 'Door access pattern suggests possible tailgating at Door A',
          entities: [],
          sources: ['badge:door-A'],
        },
        {
          id: 'ev-0003',
          ts_ms: mkTs(22),
          category: 'alpr_match',
          domain: 'traffic',
          severity: 3,
          severity_label: 'warning',
          status: 'open',
          summary: 'Plate observed at west gate; matches watchlist pattern',
          entities: ['veh-07'],
          sources: ['camera:west-gate'],
        },
        {
          id: 'ev-0004',
          ts_ms: mkTs(35),
          category: 'audio_sed',
          domain: 'facility',
          severity: 1,
          severity_label: 'info',
          status: 'closed',
          summary: 'Short impulse sound detected; no follow-on indicators',
          entities: [],
          sources: ['mic:yard-1'],
        },
        {
          id: 'ev-0005',
          ts_ms: mkTs(4),
          category: 'restricted_area_entry',
          domain: 'facility',
          severity: 4,
          severity_label: 'critical',
          status: 'open',
          summary: 'Movement detected within a restricted zone near the loading bay',
          entities: ['ent-01'],
          sources: ['camera:loading-bay'],
        },
        {
          id: 'ev-0006',
          ts_ms: mkTs(16),
          category: 'loitering',
          domain: 'facility',
          severity: 2,
          severity_label: 'notice',
          status: 'open',
          summary: 'Loitering behavior near the visitor entrance (possible recon)',
          entities: ['ent-02'],
          sources: ['camera:visitor-entrance'],
        },
        {
          id: 'ev-0007',
          ts_ms: mkTs(28),
          category: 'access_anomaly',
          domain: 'access',
          severity: 2,
          severity_label: 'notice',
          status: 'open',
          summary: 'Multiple badge retries at Door A outside normal pattern',
          entities: [],
          sources: ['badge:door-A'],
        },
      ];

      const tasks = [
        {
          id: 'task-1001',
          event_id: 'ev-0001',
          action: 'dispatch_patrol',
          asset_id: 'north_fence',
          infrastructure_type: 'patrol',
          assignee_domain: 'security',
          status: 'proposed',
          priority: 3,
          confidence: 0.76,
          rationale: 'Confirm area is clear and deter intrusion.',
        },
        {
          id: 'task-1002',
          event_id: 'ev-0003',
          action: 'notify',
          asset_id: 'west_gate',
          infrastructure_type: 'comm',
          assignee_domain: 'security',
          status: 'proposed',
          priority: 2,
          confidence: 0.64,
          rationale: 'Notify on-duty staff; verify plate via secondary camera.',
        },
        {
          id: 'task-1003',
          event_id: 'ev-0002',
          action: 'lock',
          asset_id: 'door-A',
          infrastructure_type: 'access_control',
          assignee_domain: 'security',
          status: 'pending',
          priority: 2,
          confidence: 0.58,
          rationale: 'Temporarily lock Door A pending verification (tailgating indicators).',
        },
        {
          id: 'task-1004',
          event_id: 'ev-0005',
          action: 'dispatch_patrol',
          asset_id: 'loading_bay',
          infrastructure_type: 'patrol',
          assignee_domain: 'security',
          status: 'approved',
          priority: 4,
          confidence: 0.81,
          rationale: 'Immediate on-site verification for restricted zone entry.',
        },
      ];

      const intents = [
        {
          id: 'intent-demo-delta',
          text: 'Delta formation over Line Bravo',
          domain: 'air',
          desired_effects: ['formation_delta'],
          constraints: ['line_bravo', 'maintain_spacing'],
          timing: 'immediate',
          priority: 'high',
        },
        {
          id: 'intent-demo-box',
          text: 'Box around the loading bay and hold',
          domain: 'air',
          desired_effects: ['formation_box', 'hold_position'],
          constraints: ['loading_bay'],
          timing: 'immediate',
          priority: 'high',
        },
        {
          id: 'intent-demo-line',
          text: 'Hold a line facing west across the approach',
          domain: 'air',
          desired_effects: ['hold_line'],
          constraints: ['facing_west'],
          timing: 'immediate',
          priority: 'medium',
        },
      ];

      const playbookActions = [
        {
          id: 'pb-demo-delta',
          name: 'delta',
          parameters: { formation: 'delta', target: 'drone-01', span_m: 400 },
          domain: 'air',
          rationale: 'Map intent to delta formation',
          derived_from_intent: 'intent-demo-delta',
        },
        {
          id: 'pb-demo-box',
          name: 'box',
          parameters: { formation: 'box', target: 'drone-02', anchor: 'loading bay' },
          domain: 'air',
          rationale: 'Box around loading bay',
          derived_from_intent: 'intent-demo-box',
        },
        {
          id: 'pb-demo-line',
          name: 'hold_position',
          parameters: { formation: 'line', target: 'drone-02', hold_radius_m: 120, facing: 'west' },
          domain: 'air',
          rationale: 'Hold line facing west',
          derived_from_intent: 'intent-demo-line',
        },
      ];

      const assets = [
        {
          id: 'drone-01',
          domain: 'air',
          vehicle_type: 'quadcopter',
          label: 'Raven-1',
          status: 'available',
          battery_pct: 0.82,
          comm_link: { link: 'sat', strength: 0.82 },
          route: [{ lat: 34.0525, lon: -118.2442, alt_m: 120, eta_epoch: (nowMs / 1000) + 600 }],
          link_state: { target: 'drone-01', available: true, last_check_epoch: nowMs / 1000, metrics: { rssi: -65 } },
        },
        {
          id: 'drone-02',
          domain: 'air',
          vehicle_type: 'quadcopter',
          label: 'Raven-2',
          status: 'tasked',
          battery_pct: 0.54,
          comm_link: { link: 'mesh', strength: 0.61 },
          route: [{ lat: 34.0521, lon: -118.2455, alt_m: 80, eta_epoch: (nowMs / 1000) + 420 }],
          link_state: { target: 'drone-02', available: false, window_ends_epoch: (nowMs / 1000) + 300, notes: 'Reacquire after pass', metrics: { packet_loss: 0.32 } },
        },
        {
          id: 'wing-01',
          domain: 'air',
          vehicle_type: 'fixed_wing',
          label: 'Wing-01',
          status: 'link_only',
          battery_pct: 0.93,
          comm_link: { link: 'sat', strength: 0.9 },
          route: [],
          link_state: { target: 'wing-01', available: true, last_check_epoch: nowMs / 1000 },
        },
      ];

      const platformCommands = [
        { id: 'cmd-1001', command: 'hold_position', target: 'drone-02', asset_id: 'drone-02', domain: 'air', status: 'queued', priority: 2, args: { event_id: 'ev-0005' }, link_state: assets[1].link_state, intent_id: 'intent-demo-box', playbook_action_id: 'pb-demo-box' },
        { id: 'cmd-1002', command: 'observe', target: 'drone-01', asset_id: 'drone-01', domain: 'air', status: 'sent', priority: 3, args: { event_id: 'ev-0001' }, link_state: assets[0].link_state, intent_id: 'intent-demo-delta', playbook_action_id: 'pb-demo-delta' },
      ];

      const suggestion = {
        id: 'suggestion-0001',
        proposed_at: Math.floor(nowMs / 1000),
        status: 'proposed',
        plain_text: 'Dispatch a patrol to the loading bay and north fence line. Notify west gate staff to verify the plate match; hold Door A for review if tailgating persists.',
        recommended: {
          action: 'dispatch_patrol',
          asset_id: 'north_fence',
          infrastructure_type: 'patrol',
          assignee_domain: 'security',
          rationale: 'Confirm area is clear and deter intrusion.',
        },
        summary: {
          events_seen: events.length,
          tasks_approved: tasks.filter(t => t.status === 'approved').length,
          tasks_pending: tasks.filter(t => t.status !== 'approved').length,
          top_event: { id: 'ev-0005', category: 'restricted_area_entry', domain: 'facility', severity: 'critical' },
        },
      };

      const audit = [
        { seq: 1, ts_unix: Math.floor(mkTs(38) / 1000), kind: 'ingest_modules_done', actor: 'system', payload: { path: 'out/modules_media.jsonl', stride: 8, stats: { vision: 128, audio: 14, gait: 52, scene: 9 } } },
        { seq: 2, ts_unix: Math.floor(mkTs(37) / 1000), kind: 'rules_done', actor: 'system', payload: { events: 6, events_after_governance: 4, blocked: 2 } },
        { seq: 3, ts_unix: Math.floor(mkTs(36) / 1000), kind: 'guardrails', actor: 'system', payload: { kept: 2, dropped_rate_limit: 1, dropped_risk_budget: 0 } },
        { seq: 4, ts_unix: Math.floor(mkTs(6) / 1000), kind: 'action_suggestion', actor: 'system', payload: { status: 'proposed', recommended: suggestion.recommended } },
        { seq: 5, ts_unix: Math.floor(mkTs(5) / 1000), kind: 'ontology_graph_written', actor: 'system', payload: { path: 'out/graph.json', nodes: 7, edges: 4 } },
      ];

      const entityProfiles = {
        schema_version: '0.1',
        generated_at: new Date(nowMs).toISOString(),
        has_gait_tracks: true,
        summaries: [
          { entity_id: 'ent-01', track_id: 'trk-01', num_observations: 18, dominant_camera: 'north-fence', dominant_hour_of_day: 2, time_span_seconds: 240.5 },
          { entity_id: 'ent-02', track_id: 'trk-02', num_observations: 9, dominant_camera: 'visitor-entrance', dominant_hour_of_day: 1, time_span_seconds: 132.9 },
          { entity_id: 'veh-07', track_id: 'trk-veh-07', num_observations: 6, dominant_camera: 'west-gate', dominant_hour_of_day: 1, time_span_seconds: 88.2 },
        ],
        entities: [
          {
            entity_id: 'ent-01',
            track_id: 'trk-01',
            observations: Array.from({ length: 8 }).map((_, i) => ({
              ts_ms: mkTs(20 - i * 2),
              camera_id: 'north-fence',
              note: i === 0 ? 'Entered frame edge; slow pace' : 'Moving parallel to fence',
            })),
          },
          {
            entity_id: 'ent-02',
            track_id: 'trk-02',
            observations: Array.from({ length: 7 }).map((_, i) => ({
              ts_ms: mkTs(18 - i * 2),
              camera_id: 'visitor-entrance',
              note: i === 0 ? 'Paused near entrance signage' : 'Loitering near entrance',
            })),
          },
          {
            entity_id: 'veh-07',
            track_id: 'trk-veh-07',
            observations: Array.from({ length: 6 }).map((_, i) => ({
              ts_ms: mkTs(24 - i * 3),
              camera_id: 'west-gate',
              note: i === 0 ? 'Plate detected (partial)' : 'Vehicle slowing near gate',
            })),
          },
        ],
      };

      const casebook = {
        schema_version: '0.1',
        cases: [
          {
            id: 'case-001',
            title: 'Night perimeter anomaly (north fence)',
            description: 'Track repeated movement near the north fence during after-hours. Confirm whether this is benign activity or probing.',
            status: 'open',
            opened_at: Math.floor(mkTs(55) / 1000),
            domain: 'facility',
            classification: 'CUI',
          },
        ],
        evidence: [
          {
            id: 'evidence-001',
            kind: 'CCTVClip',
            description: 'Short clip from north fence camera showing movement along fence line.',
            source: 'operator',
            created_at: Math.floor(mkTs(50) / 1000),
            uri: 'out/demo_clip.mp4',
            case_ids: ['case-001'],
            tags: ['perimeter', 'after-hours'],
            classification: 'CUI',
          },
        ],
        hypotheses: [
          {
            id: 'hyp-001',
            title: 'Fence probing (low confidence)',
            description: 'Movement indicates potential probing for weak points rather than an immediate breach attempt.',
            status: 'open',
            confidence: 0.35,
            rationale: 'Repeated movement without entry attempt; timing is after-hours.',
            created_at: Math.floor(mkTs(48) / 1000),
            updated_at: Math.floor(mkTs(12) / 1000),
            case_ids: ['case-001'],
            evidence_ids: ['evidence-001'],
            classification: 'CUI',
          },
        ],
      };

      const graph = {
        schema_version: '0.1',
        generated_at: new Date(nowMs).toISOString(),
        nodes: [
          { id: 'event:ev-0001', type: 'event', label: 'Perimeter anomaly (north fence)', props: { severity: 'warning', domain: 'facility', geo: { lat: 34.05220, lon: -118.24370 } } },
          { id: 'task:task-1001', type: 'task', label: 'dispatch_patrol', props: { status: 'proposed' } },
          { id: 'event:ev-0005', type: 'event', label: 'Restricted area entry (loading bay)', props: { severity: 'critical', domain: 'facility', geo: { lat: 34.05155, lon: -118.24510 } } },
          { id: 'task:task-1004', type: 'task', label: 'dispatch_patrol', props: { status: 'approved' } },
          { id: 'event:ev-0002', type: 'event', label: 'Possible tailgating (Door A)', props: { severity: 'notice', domain: 'access', geo: { lat: 34.05295, lon: -118.24290 } } },
          { id: 'task:task-1003', type: 'task', label: 'lock', props: { status: 'pending' } },
          { id: 'event:ev-0006', type: 'event', label: 'Loitering (visitor entrance)', props: { severity: 'notice', domain: 'facility', geo: { lat: 34.05335, lon: -118.24430 } } },
          { id: 'event:ev-0003', type: 'event', label: 'Plate watchlist pattern (west gate)', props: { severity: 'warning', domain: 'traffic', geo: { lat: 34.05190, lon: -118.24630 } } },
          { id: 'task:task-1002', type: 'task', label: 'notify', props: { status: 'proposed' } },
          { id: 'case:case-001', type: 'case', label: 'Night perimeter anomaly (north fence)', props: { status: 'open' } },
          { id: 'evidence:evidence-001', type: 'evidence', label: 'North fence clip', props: { kind: 'CCTVClip' } },
          { id: 'entity:ent-01', type: 'entity', label: 'Entity ent-01', props: { track_id: 'trk-01' } },
          { id: 'entity:ent-02', type: 'entity', label: 'Entity ent-02', props: { track_id: 'trk-02' } },
        ],
        edges: [
          { source: 'task:task-1001', type: 'RESPONDS_TO', target: 'event:ev-0001', props: {} },
          { source: 'task:task-1004', type: 'RESPONDS_TO', target: 'event:ev-0005', props: {} },
          { source: 'task:task-1003', type: 'RESPONDS_TO', target: 'event:ev-0002', props: {} },
          { source: 'task:task-1002', type: 'RESPONDS_TO', target: 'event:ev-0003', props: {} },
          { source: 'evidence:evidence-001', type: 'EVIDENCE_FOR', target: 'case:case-001', props: {} },
          { source: 'entity:ent-01', type: 'MENTIONED_IN', target: 'event:ev-0001', props: {} },
          { source: 'entity:ent-02', type: 'MENTIONED_IN', target: 'event:ev-0006', props: {} },
        ],
        stats: {
          nodes: 13,
          edges: 7,
          node_types: ['case', 'evidence', 'entity', 'event', 'task'],
          edge_types: ['EVIDENCE_FOR', 'MENTIONED_IN', 'RESPONDS_TO'],
        },
      };

      const metrics = {
        helios_ingest_count: 1,
        helios_fusion_count: 1,
        helios_rules_count: 1,
        helios_events_raw: 6,
        helios_decision_count: 2,
        helios_guardrails_count: 1,
        helios_risk_budget_count: 0,
        helios_autonomy_count: 1,
        helios_export_json_writes: 4,
        helios_ingest_seconds: 0.48,
        helios_fusion_seconds: 0.22,
        helios_rules_seconds: 0.19,
        helios_decision_seconds: 0.11,
        helios_guardrails_seconds: 0.07,
        helios_risk_budget_seconds: 0.03,
        helios_autonomy_seconds: 0.06,
      };

      return { created_at_ms: nowMs, cfg, metrics, events, tasks, intents, playbook_actions: playbookActions, assets, platform_commands: platformCommands, suggestion, audit, entityProfiles, casebook, graph };
    }

    // -------------------- Formation Visualization & Voice --------------------
    function formationList() {
      return Object.keys(formationLibrary);
    }

    function pickPalette(domain) {
      const key = (domain || 'multi').toLowerCase();
      return formationPalette[key] || formationPalette.multi;
    }

    function seedVehicle(asset, idx) {
      const domain = (asset?.domain || 'multi').toLowerCase();
      const palette = pickPalette(domain);
      return {
        x: Math.random(),
        y: Math.random(),
        tx: Math.random(),
        ty: Math.random(),
        color: palette.fill,
        domain,
        vehicle_type: asset?.vehicle_type || null,
        label: asset?.label || asset?.id || `V-${idx + 1}`,
        palette,
      };
    }

    function ensureFormationVehiclesFor(sim, count, assets) {
      if (!sim) return;
      const v = sim.vehicles;
      const needed = Math.max(count || 0, 6);
      for (let i = 0; i < needed; i++) {
        const asset = Array.isArray(assets) && assets.length ? assets[i % assets.length] : null;
        if (!v[i]) {
          v[i] = seedVehicle(asset, i);
        } else if (asset) {
          const palette = pickPalette(asset.domain);
          v[i].domain = (asset.domain || v[i].domain || 'multi').toLowerCase();
          v[i].vehicle_type = asset.vehicle_type || v[i].vehicle_type;
          v[i].label = asset.label || asset.id || v[i].label;
          v[i].color = palette.fill;
          v[i].palette = palette;
        } else {
          v[i].palette = pickPalette(v[i].domain);
        }
        // Keep seed positions inside the current canvas if available.
        if (sim.canvas && (v[i].x == null || v[i].y == null || v[i].x <= 1 || v[i].y <= 1)) {
          v[i].x = Math.random() * sim.canvas.width;
          v[i].y = Math.random() * sim.canvas.height;
        }
      }
      if (v.length > needed) v.length = needed;
    }

    function ensureFormationVehicles(count, assets) {
      ensureFormationVehiclesFor(formationSim, count, assets);
    }

    function formationTargetsNormalized(name, count) {
      const pts = formationLibrary[name] || formationLibrary.line;
      const out = [];
      for (let i = 0; i < count; i++) {
        const src = pts[i % pts.length];
        const jitterX = (Math.random() - 0.5) * 0.08;
        const jitterY = (Math.random() - 0.5) * 0.08;
        const nx = (src[0] + jitterX + 1) / 2; // 0..1
        const ny = (src[1] + jitterY + 1) / 2;
        out.push({ nx, ny });
      }
      return out;
    }

    function formationTargets(name, count, w, h) {
      const norm = formationTargetsNormalized(name, count);
      const pad = 20;
      return norm.map(({ nx, ny }) => ({ x: pad + nx * (w - pad * 2), y: pad + ny * (h - pad * 2) }));
    }

    function drawVehicle(ctx, v, idx) {
      const p = v.palette || pickPalette(v.domain);
      const shadow = p.shadow || 'rgba(0,0,0,0.45)';
      ctx.save();
      ctx.translate(v.x, v.y);
      ctx.shadowColor = shadow;
      ctx.shadowBlur = 8;
      ctx.shadowOffsetY = 2;

      // Minimal UAV silhouette: delta nose with winglets.
      ctx.beginPath();
      ctx.moveTo(0, -14);
      ctx.lineTo(12, 8);
      ctx.lineTo(4, 6);
      ctx.lineTo(0, 12);
      ctx.lineTo(-4, 6);
      ctx.lineTo(-12, 8);
      ctx.closePath();

      const g = ctx.createLinearGradient(-12, -14, 12, 14);
      g.addColorStop(0, p.highlight);
      g.addColorStop(0.5, p.fill);
      g.addColorStop(1, p.stroke);
      ctx.fillStyle = g;
      ctx.strokeStyle = p.stroke;
      ctx.lineWidth = 1.3;
      ctx.fill();
      ctx.stroke();

      // Top stripe.
      ctx.beginPath();
      ctx.strokeStyle = p.highlight;
      ctx.lineWidth = 1;
      ctx.moveTo(-6, -2);
      ctx.lineTo(6, -2);
      ctx.stroke();

      ctx.shadowBlur = 0;
      ctx.font = '11px "IBM Plex Sans", system-ui, sans-serif';
      ctx.fillStyle = 'rgba(232,236,245,0.9)';
      ctx.fillText(String(idx + 1), 10, -6);
      ctx.restore();
    }

    function drawFormation() {
      const { canvas, ctx, vehicles, running } = formationSim;
      if (!canvas || !ctx) return;
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = 'rgba(13,21,43,0.82)';
      ctx.fillRect(0, 0, w, h);
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

      // Subtle grid to sit under the 3D overlay.
      const step = Math.max(20, Math.floor(Math.min(w, h) / 12));
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = step; x < w; x += step) {
        ctx.moveTo(x + 0.5, 0.5);
        ctx.lineTo(x + 0.5, h - 0.5);
      }
      for (let y = step; y < h; y += step) {
        ctx.moveTo(0.5, y + 0.5);
        ctx.lineTo(w - 0.5, y + 0.5);
      }
      ctx.stroke();

      // Draw UAV-style markers atop the grid for easy alignment.
      vehicles.forEach((p, idx) => drawVehicle(ctx, p, idx));

      if (running) {
        const fpsTxt = formationSim.formation ? `Formation: ${formationSim.formation}` : 'Moving';
        ctx.fillStyle = 'rgba(232,236,245,0.7)';
        ctx.font = '12px "IBM Plex Sans", system-ui, sans-serif';
        ctx.fillText(fpsTxt, 10, 18);
      }
    }

    function tickFormation() {
      const { vehicles, targets } = formationSim;
      if (!vehicles.length || !targets.length) return drawFormation();
      let moving = false;
      for (let i = 0; i < vehicles.length; i++) {
        const p = vehicles[i];
        const t = targets[i % targets.length];
        const dx = t.x - p.x;
        const dy = t.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const step = Math.min(1, Math.max(0.12, dist * 0.12));
        if (dist > 0.5) {
          p.x += dx * step * 0.1;
          p.y += dy * step * 0.1;
          moving = true;
        }
      }
      formationSim.running = moving;
      drawFormation();
      formationSim.raf = requestAnimationFrame(tickFormation);
    }

    function setFormation(name, reason, normTargetsOverride) {
      if (!formationSim.canvas) return;
      const normalized = (formationLibrary[name] ? name : 'line');
      formationSim.formation = normalized;
      const w = formationSim.canvas.width;
      const h = formationSim.canvas.height;
      ensureFormationVehicles(latestAssets.length || formationSim.vehicles.length || 6, latestAssets);
      const count = formationSim.vehicles.length;
      const normTargets = normTargetsOverride || reuseNormalizedTargets(normalized, count) || formationTargetsNormalized(normalized, count);
      formationSim.targets = formationTargets(normalized, count, w, h);
      setFormation3D(normalized, latestAssets, normTargets);
      persistFormationState(normalized, normTargets);
      formationSim.running = true;
      const status = document.getElementById('formation-state');
      if (status) status.textContent = `Formation ${normalized} via ${reason || 'manual'}`;
      if (!formationSim.raf) formationSim.raf = requestAnimationFrame(tickFormation);
    }

    function resetFormation() {
      if (!formationSim.canvas) return;
      ensureFormationVehicles(formationSim.vehicles.length || 6, latestAssets);
      const w = formationSim.canvas.width;
      const h = formationSim.canvas.height;
      const normTargets = reuseNormalizedTargets('line', formationSim.vehicles.length) || formationTargetsNormalized('line', formationSim.vehicles.length);
      formationSim.targets = formationTargets('line', formationSim.vehicles.length, w, h);
      setFormation3D('line', latestAssets, normTargets);
      persistFormationState('line', normTargets);
      formationSim.running = true;
      formationSim.formation = 'line';
      const formationSelect = document.getElementById('formation-select');
      if (formationSelect) formationSelect.value = 'line';
      const status = document.getElementById('formation-state');
      if (status) status.textContent = 'Reset to line';
      if (!formationSim.raf) formationSim.raf = requestAnimationFrame(tickFormation);
    }

    function matchFormationPhrase(haystack, phrase) {
      if (!haystack || !phrase) return false;
      const escaped = phrase.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const pattern = new RegExp(`\\b${escaped.replace(/\s+/g, '\\s+')}\\b`, 'i');
      return pattern.test(haystack);
    }

    function parseFormationFromText(text, legendOverride) {
      if (!text) return null;
      const lower = text.toLowerCase();
      const voiceLegend = legendOverride || formationVoiceLegend;
      const priority = ['box', 'delta', 'wedge', 'echelon_left', 'echelon_right', 'column', 'line'];

      for (const key of priority) {
        const phrases = voiceLegend[key] || [];
        if (phrases.some(p => matchFormationPhrase(lower, p))) return key;
      }

      const keys = [...priority, ...formationList().filter(k => !priority.includes(k))];
      for (const key of keys) {
        const simple = key.replace(/_/g, ' ');
        if (matchFormationPhrase(lower, key) || matchFormationPhrase(lower, simple)) return key;
      }
      return null;
    }

    function initFormationViz() {
      const canvas = document.getElementById('formation-canvas');
      const select = document.getElementById('formation-select');
      const stateEl = document.getElementById('formation-state');
      if (!canvas || !select) return;
      formationSim.canvas = canvas;
      syncFormationCanvasSize();
      formationSim.ctx = canvas.getContext('2d');
      formationList().forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name.replace('_', ' ');
        select.appendChild(opt);
      });
      const persisted = loadPersistedFormation();
      if (persisted && formationLibrary[persisted.formation]) {
        formationSim.formation = persisted.formation;
        select.value = persisted.formation;
      } else if (!select.value) {
        select.value = 'delta';
      }
      ensureFormationVehicles(latestAssets.length || 6, latestAssets);
      if (formationSim.formation) {
        const count = formationSim.vehicles.length || 6;
        const normTargets = reuseNormalizedTargets(formationSim.formation, count) || formationTargetsNormalized(formationSim.formation, count);
        setFormation(formationSim.formation, 'persisted', normTargets);
      } else {
        resetFormation();
      }
      updateFormationSourceUI();
      updateFormationRoster();
      renderFormationLegend(latestAssets);
      setFormationLegendCollapsed(true);
      if (stateEl) stateEl.textContent = 'Ready';
      initFormation3D();
      refreshFormationViz();

      const applyBtn = document.getElementById('formation-apply');
      if (applyBtn) applyBtn.addEventListener('click', () => {
        const val = select.value || 'line';
        setFormation(val, 'manual');
      });
      const resetBtn = document.getElementById('formation-reset');
      if (resetBtn) resetBtn.addEventListener('click', () => resetFormation());
      const legendToggle = document.getElementById('formation-legend-toggle');
      if (legendToggle) legendToggle.addEventListener('click', () => setFormationLegendCollapsed(!formationLegendCollapsed));
    }

    function refreshFormationViz() {
      const dash = document.getElementById('dashboard');
      const data = document.getElementById('data');
      const dashVisible = dash && dash.style.display !== 'none';
      const dataVisible = data && data.style.display !== 'none';
      if (!dashVisible && !dataVisible) return;
      const doRefresh = () => {
        syncFormationCanvasSize();
        drawFormation();
        if (!formation3d.ready) {
          initFormation3D();
        } else {
          resizeFormation3D();
        }
      };
      requestAnimationFrame(() => {
        doRefresh();
        setTimeout(doRefresh, 50);
      });
    }

    function syncFormationCanvasSize() {
      const canvas = document.getElementById('formation-canvas');
      const wrapper = document.getElementById('formation-viz');
      if (!canvas || !wrapper) return;
      const rect = wrapper.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
        canvas.style.width = `${w}px`;
        canvas.style.height = `${h}px`;
        drawFormation();
        resizeFormation3D();
      }
    }

    function syncFormationCanvasSizeJoint() {
      const canvas = document.getElementById('joint-formation-canvas');
      const wrapper = document.getElementById('joint-formation-viz');
      if (!canvas || !wrapper) return;
      const rect = wrapper.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
        canvas.style.width = `${w}px`;
        canvas.style.height = `${h}px`;
        drawFormationJoint();
      }
    }

    function drawFormationJoint() {
      const { canvas, ctx, vehicles, running } = formationSimJoint;
      if (!canvas || !ctx) return;
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = 'rgba(13,21,43,0.86)';
      ctx.fillRect(0, 0, w, h);
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

      const step = Math.max(22, Math.floor(Math.min(w, h) / 10));
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = step; x < w; x += step) {
        ctx.moveTo(x + 0.5, 0.5);
        ctx.lineTo(x + 0.5, h - 0.5);
      }
      for (let y = step; y < h; y += step) {
        ctx.moveTo(0.5, y + 0.5);
        ctx.lineTo(w - 0.5, y + 0.5);
      }
      ctx.stroke();

      vehicles.forEach((p, idx) => drawVehicle(ctx, p, idx));

      if (running) {
        const label = formationSimJoint.formation ? `Formation: ${formationSimJoint.formation}` : 'Moving';
        ctx.fillStyle = 'rgba(232,236,245,0.7)';
        ctx.font = '12px "IBM Plex Sans", system-ui, sans-serif';
        ctx.fillText(label, 10, 18);
      }
    }

    function tickFormationJoint() {
      const { vehicles, targets } = formationSimJoint;
      if (!vehicles.length || !targets.length) return drawFormationJoint();
      let moving = false;
      for (let i = 0; i < vehicles.length; i++) {
        const p = vehicles[i];
        const t = targets[i % targets.length];
        const dx = t.x - p.x;
        const dy = t.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const step = Math.min(1, Math.max(0.12, dist * 0.12));
        if (dist > 0.5) {
          p.x += dx * step * 0.1;
          p.y += dy * step * 0.1;
          moving = true;
        }
      }
      formationSimJoint.running = moving;
      drawFormationJoint();
      formationSimJoint.raf = requestAnimationFrame(tickFormationJoint);
    }

    function setFormationJoint(name, reason, normTargetsOverride) {
      if (!formationSimJoint.canvas) return;
      const normalized = (formationLibrary[name] ? name : 'line');
      formationSimJoint.formation = normalized;
      const w = formationSimJoint.canvas.width;
      const h = formationSimJoint.canvas.height;
      ensureFormationVehiclesFor(formationSimJoint, latestAssets.length || formationSimJoint.vehicles.length || 6, latestAssets);
      const count = formationSimJoint.vehicles.length;
      const normTargets = normTargetsOverride || reuseNormalizedTargetsJoint(normalized, count) || formationTargetsNormalized(normalized, count);
      formationSimJoint.targets = formationTargets(normalized, count, w, h);
      persistFormationStateJoint(normalized, normTargets);
      formationSimJoint.running = true;
      const status = document.getElementById('joint-formation-state');
      if (status) status.textContent = `Formation ${normalized} via ${reason || 'manual'}`;
      if (!formationSimJoint.raf) formationSimJoint.raf = requestAnimationFrame(tickFormationJoint);
    }

    function resetFormationJoint() {
      if (!formationSimJoint.canvas) return;
      ensureFormationVehiclesFor(formationSimJoint, formationSimJoint.vehicles.length || 6, latestAssets);
      const w = formationSimJoint.canvas.width;
      const h = formationSimJoint.canvas.height;
      const normTargets = reuseNormalizedTargetsJoint('line', formationSimJoint.vehicles.length) || formationTargetsNormalized('line', formationSimJoint.vehicles.length);
      formationSimJoint.targets = formationTargets('line', formationSimJoint.vehicles.length, w, h);
      persistFormationStateJoint('line', normTargets);
      formationSimJoint.running = true;
      formationSimJoint.formation = 'line';
      const formationSelect = document.getElementById('joint-formation-select');
      if (formationSelect) formationSelect.value = 'line';
      const status = document.getElementById('joint-formation-state');
      if (status) status.textContent = 'Reset to line';
      if (!formationSimJoint.raf) formationSimJoint.raf = requestAnimationFrame(tickFormationJoint);
    }

    function initFormationVizJoint() {
      const canvas = document.getElementById('joint-formation-canvas');
      const select = document.getElementById('joint-formation-select');
      const stateEl = document.getElementById('joint-formation-state');
      if (!canvas || !select) return;
      formationSimJoint.canvas = canvas;
      syncFormationCanvasSizeJoint();
      formationSimJoint.ctx = canvas.getContext('2d');
      if (!select.options.length) {
        formationList().forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name.replace('_', ' ');
          select.appendChild(opt);
        });
      }
      const persisted = loadPersistedFormationJoint();
      if (persisted && formationLibrary[persisted.formation]) {
        formationSimJoint.formation = persisted.formation;
        select.value = persisted.formation;
      } else if (!select.value) {
        select.value = 'delta';
      }
      ensureFormationVehiclesFor(formationSimJoint, latestAssets.length || 6, latestAssets);
      if (formationSimJoint.formation) {
        const count = formationSimJoint.vehicles.length || 6;
        const normTargets = reuseNormalizedTargetsJoint(formationSimJoint.formation, count) || formationTargetsNormalized(formationSimJoint.formation, count);
        setFormationJoint(formationSimJoint.formation, 'persisted', normTargets);
      } else {
        resetFormationJoint();
      }
      updateJointFormationSourceUI();
      updateJointFormationRoster();
      renderFormationLegendJoint(latestAssets);
      setFormationLegendCollapsedJoint(true);
      if (stateEl) stateEl.textContent = 'Ready';
      refreshFormationVizJoint();

      const applyBtn = document.getElementById('joint-formation-apply');
      if (applyBtn) applyBtn.addEventListener('click', () => {
        const val = select.value || 'line';
        setFormationJoint(val, 'manual');
      });
      const resetBtn = document.getElementById('joint-formation-reset');
      if (resetBtn) resetBtn.addEventListener('click', () => resetFormationJoint());
      const legendToggle = document.getElementById('joint-formation-legend-toggle');
      if (legendToggle) legendToggle.addEventListener('click', () => setFormationLegendCollapsedJoint(!jointFormationLegendCollapsed));

      const voiceStart = document.getElementById('joint-voice-start');
      const voiceStop = document.getElementById('joint-voice-stop');
      if (voiceStart) voiceStart.addEventListener('click', startVoiceJoint);
      if (voiceStop) voiceStop.addEventListener('click', stopVoiceJoint);

      window.addEventListener('resize', () => syncFormationCanvasSizeJoint());
    }

    function refreshFormationVizJoint() {
      const joint = document.getElementById('joint');
      const jointVisible = joint && joint.style.display !== 'none';
      if (!jointVisible) return;
      const doRefresh = () => {
        syncFormationCanvasSizeJoint();
        drawFormationJoint();
      };
      requestAnimationFrame(() => {
        doRefresh();
        setTimeout(doRefresh, 50);
      });
    }

    // -------------------- Voice input (Web Speech API) --------------------
    function setVoiceStatus(msg) {
      const voiceStatus = document.getElementById('formation-voice-status');
      if (voiceStatus) voiceStatus.textContent = msg;
    }

    function simulateVoiceOnce() {
      const phrase = window.prompt('Speech API not available. Type a phrase to simulate a voice command:', 'delta formation over line bravo');
      if (!phrase) {
        setVoiceStatus('Speech API not available');
        return;
      }
      formationSim.lastHeard = phrase;
      setVoiceStatus(`Simulated: ${phrase}`);
      const maybe = parseFormationFromText(phrase);
      if (maybe) setFormation(maybe, 'voice-simulated');
    }

    function initVoice() {
      const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition || window.msSpeechRecognition;
      const secureOk = window.isSecureContext || ['localhost', '127.0.0.1'].includes(window.location.hostname);
      if (!secureOk) setVoiceStatus('Use HTTPS or localhost for mic access');
      if (!SpeechRec) {
        setVoiceStatus('Speech API not available');
        return null;
      }
      const rec = new SpeechRec();
      rec.lang = 'en-US';
      rec.continuous = true;
      rec.interimResults = false;
      rec.onresult = (ev) => {
        const phrase = ev.results[ev.results.length - 1][0].transcript.trim();
        formationSim.lastHeard = phrase;
        setVoiceStatus(`Heard: ${phrase}`);
        const maybe = parseFormationFromText(phrase);
        if (maybe) setFormation(maybe, 'voice');
      };
      rec.onstart = () => { formationSim.voiceActive = true; setVoiceStatus('Listening...'); };
      rec.onend = () => { formationSim.voiceActive = false; setVoiceStatus('Stopped'); };
      rec.onerror = (ev) => {
        formationSim.voiceActive = false;
        const reason = ev && ev.error ? ev.error : 'Voice error';
        setVoiceStatus(`Voice error (${reason}). Check mic permissions in Edge.`);
      };
      formationSim.voiceRecognition = rec;
      return rec;
    }

    function startVoice() {
      if (!formationSim.voiceRecognition) initVoice();
      const rec = formationSim.voiceRecognition;
      if (!rec) {
        simulateVoiceOnce();
        return;
      }
      try {
        rec.start();
      } catch (err) {
        setVoiceStatus('Voice start blocked. Allow mic in Edge or use simulate.');
      }
    }

    function stopVoice() {
      const rec = formationSim.voiceRecognition;
      if (!rec) return;
      try { rec.stop(); } catch (_) {}
    }

    // -------------------- Joint Ops voice input --------------------
    function setVoiceStatusJoint(msg) {
      const voiceStatus = document.getElementById('joint-formation-voice-status');
      if (voiceStatus) voiceStatus.textContent = msg;
    }

    function simulateVoiceOnceJoint() {
      const phrase = window.prompt('Speech API not available. Type a phrase to simulate a joint voice command:', 'capture this base');
      if (!phrase) {
        setVoiceStatusJoint('Speech API not available');
        return;
      }
      formationSimJoint.lastHeard = phrase;
      setVoiceStatusJoint(`Simulated: ${phrase}`);
      const maybe = parseFormationFromText(phrase, formationVoiceLegendJoint);
      if (maybe) setFormationJoint(maybe, 'voice-simulated');
      setJointObjective(phrase);
    }

    function initVoiceJoint() {
      const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition || window.msSpeechRecognition;
      const secureOk = window.isSecureContext || ['localhost', '127.0.0.1'].includes(window.location.hostname);
      if (!secureOk) setVoiceStatusJoint('Use HTTPS or localhost for mic access');
      if (!SpeechRec) {
        setVoiceStatusJoint('Speech API not available');
        return null;
      }
      const rec = new SpeechRec();
      rec.lang = 'en-US';
      rec.continuous = true;
      rec.interimResults = false;
      rec.onresult = (ev) => {
        const phrase = ev.results[ev.results.length - 1][0].transcript.trim();
        formationSimJoint.lastHeard = phrase;
        setVoiceStatusJoint(`Heard: ${phrase}`);
        const maybe = parseFormationFromText(phrase, formationVoiceLegendJoint);
        if (maybe) setFormationJoint(maybe, 'voice');
        setJointObjective(phrase);
      };
      rec.onstart = () => { formationSimJoint.voiceActive = true; setVoiceStatusJoint('Listening...'); };
      rec.onend = () => { formationSimJoint.voiceActive = false; setVoiceStatusJoint('Stopped'); };
      rec.onerror = (ev) => {
        formationSimJoint.voiceActive = false;
        const reason = ev && ev.error ? ev.error : 'Voice error';
        setVoiceStatusJoint(`Voice error (${reason}). Check mic permissions in Edge.`);
      };
      formationSimJoint.voiceRecognition = rec;
      return rec;
    }

    function startVoiceJoint() {
      if (!formationSimJoint.voiceRecognition) initVoiceJoint();
      const rec = formationSimJoint.voiceRecognition;
      if (!rec) {
        simulateVoiceOnceJoint();
        return;
      }
      try {
        rec.start();
      } catch (err) {
        setVoiceStatusJoint('Voice start blocked. Allow mic in Edge or use simulate.');
      }
    }

    function stopVoiceJoint() {
      const rec = formationSimJoint.voiceRecognition;
      if (!rec) return;
      try { rec.stop(); } catch (_) {}
    }

    function getDemoState() {
      if (!window.__heliosDemoState) window.__heliosDemoState = buildDemoState();
      return window.__heliosDemoState;
    }

    // -------------------- Intel UI --------------------
    const intelTabs = {
      entity: { title: 'Entity Profiles', desc: 'Derived from modules_media outputs when available (out/entity_profiles.json).' },
      casebook: { title: 'Casebook', desc: 'Local case/evidence/hypothesis tracker (out/casebook.json).' },
      enhance: { title: 'Vision Enhancement', desc: 'Conservative deterministic enhancement + optional face redaction.' },
      graph: { title: 'Graph', desc: 'Lightweight ontology graph built from events, casebook, and entity profiles (out/graph.json).' },
    };
    let selectedIntelTab = 'entity';
    let intelInitialized = false;

    function initIntelUI() {
      if (intelInitialized) return;
      intelInitialized = true;
      const nav = document.getElementById('intel-nav');
      if (!nav) return;
      nav.innerHTML = '';
      Object.entries(intelTabs).forEach(([key, meta]) => {
        const btn = document.createElement('button');
        btn.className = `chip ${selectedIntelTab === key ? 'active' : ''}`;
        btn.dataset.tab = key;
        btn.textContent = meta.title;
        btn.addEventListener('click', () => {
          selectedIntelTab = key;
          updateIntelNavActive();
          showIntelTab(key);
          loadIntelSelected();
        });
        nav.appendChild(btn);
      });
      updateIntelNavActive();
      showIntelTab(selectedIntelTab);
      renderIntelEntitySkeleton();
      renderIntelCasebookSkeleton();
      renderIntelEnhanceSkeleton();
      renderIntelGraphSkeleton();
    }

    function updateIntelNavActive() {
      const nav = document.getElementById('intel-nav');
      if (!nav) return;
      nav.querySelectorAll('.chip').forEach(chip => {
        chip.classList.toggle('active', chip.dataset.tab === selectedIntelTab);
      });
    }

    function showIntelTab(tab) {
      const entity = document.getElementById('intel-entity');
      const casebook = document.getElementById('intel-casebook');
      const enhance = document.getElementById('intel-enhance');
      const graph = document.getElementById('intel-graph');
      if (!entity || !casebook || !enhance || !graph) return;
      entity.style.display = tab === 'entity' ? 'grid' : 'none';
      casebook.style.display = tab === 'casebook' ? 'grid' : 'none';
      enhance.style.display = tab === 'enhance' ? 'grid' : 'none';
      graph.style.display = tab === 'graph' ? 'grid' : 'none';
    }

    function loadIntelSelected() {
      if (selectedIntelTab === 'entity') return loadEntityProfiles();
      if (selectedIntelTab === 'casebook') return loadCasebook();
      if (selectedIntelTab === 'enhance') return; // user-driven submit
      if (selectedIntelTab === 'graph') return loadGraph();
    }

    function renderIntelEntitySkeleton() {
      const grid = document.getElementById('intel-entity');
      if (!grid) return;
      grid.innerHTML = '';
      const info = document.createElement('div');
      info.className = 'card';
      info.innerHTML = `<h3>${intelTabs.entity.title}</h3>
        <p class="muted">${intelTabs.entity.desc}</p>
        <div class="toolbar"><button class="pill-button" id="profiles-refresh">Refresh</button></div>
        <div id="profiles-meta" class="muted">Loading...</div>
        <details class="nl-raw"><summary>Raw JSON (advanced)</summary><pre id="profiles-meta-raw">—</pre></details>`;
      const list = document.createElement('div');
      list.className = 'card';
      list.innerHTML = `<h3>Summaries</h3><table class="table" id="profiles-table"></table>`;
      const detail = document.createElement('div');
      detail.className = 'card';
      detail.innerHTML = `<h3>Entity Detail</h3>
        <div class="status-row"><span class="muted small">Entity ID</span><input id="profiles-entity-id" type="text" placeholder="ent-track or ent-uuid" /></div>
        <button class="pill-button" id="profiles-show">Show</button>
        <div id="profiles-detail" class="muted">Select an entity from the table or enter an entity id.</div>
        <details class="nl-raw"><summary>Raw JSON (advanced)</summary><pre id="profiles-detail-raw">—</pre></details>`;
      grid.appendChild(info);
      grid.appendChild(list);
      grid.appendChild(detail);

      const refresh = document.getElementById('profiles-refresh');
      if (refresh) refresh.addEventListener('click', () => loadEntityProfiles(true));
      const show = document.getElementById('profiles-show');
      if (show) show.addEventListener('click', () => {
        const id = document.getElementById('profiles-entity-id')?.value;
        if (id) renderEntityProfileDetail(window.__heliosEntityProfiles || null, id);
      });
    }

    async function loadEntityProfiles(force = false) {
      try {
        if (demoMode) {
          const demo = getDemoState();
          window.__heliosEntityProfiles = demo.entityProfiles;
          renderEntityProfiles(demo.entityProfiles);
          return;
        }
        const res = await fetch('/api/entity_profiles', { cache: force ? 'reload' : 'default' });
        if (!res.ok) throw new Error('entity profiles not found');
        const data = await res.json();
        window.__heliosEntityProfiles = data;
        renderEntityProfiles(data);
      } catch (e) {
        window.__heliosEntityProfiles = null;
        const meta = document.getElementById('profiles-meta');
        const table = document.getElementById('profiles-table');
        const detail = document.getElementById('profiles-detail');
        if (meta) meta.textContent = 'entity_profiles.json not found yet. Run ingest.mode: modules_media to generate.';
        if (table) table.innerHTML = '<tr><td class="muted" colspan="6">No entity profiles available.</td></tr>';
        if (detail) detail.textContent = 'No entity profile loaded.';
      }
    }

    function renderEntityProfiles(data) {
      const meta = document.getElementById('profiles-meta');
      const table = document.getElementById('profiles-table');
      const raw = document.getElementById('profiles-meta-raw');
      if (!meta || !table) return;
      const summaries = data?.summaries || [];
      const entitiesCount = (data?.entities || []).length;
      const generatedAt = data?.generated_at ? new Date(data.generated_at).toLocaleString() : '—';
      const sourceLabel = demoMode ? 'Demo Data (seeded)' : 'Live API (/api/entity_profiles)';
      meta.innerHTML = `<div class="nl">
        <div class="k">What this is</div>
        <div class="v">Non-identifying summaries of tracked entities</div>
        <ul class="nl-list">
          <li>${entitiesCount} entity record(s), ${summaries.length} summary row(s)</li>
          <li>Gait tracks present: ${data?.has_gait_tracks ? 'yes' : 'no/unknown'}</li>
          <li>Generated: ${generatedAt}</li>
          <li>Source: ${escapeHtml(sourceLabel)}</li>
        </ul>
      </div>`;
      if (raw) raw.textContent = JSON.stringify(data, null, 2);

      if (!summaries.length) {
        table.innerHTML = '<tr><td class="muted" colspan="6">No summaries.</td></tr>';
        return;
      }
      table.innerHTML = '<tr><th>Entity</th><th>Track</th><th>Obs</th><th>Dominant Camera</th><th>Dominant Hour</th><th>Span (s)</th></tr>';
      summaries.slice(0, 50).forEach(s => {
        const row = document.createElement('tr');
        row.style.cursor = 'pointer';
        row.innerHTML = `<td>${escapeHtml(s.entity_id || '—')}</td><td>${escapeHtml(s.track_id || '—')}</td><td>${escapeHtml(s.num_observations ?? 0)}</td><td>${escapeHtml(s.dominant_camera ?? '—')}</td><td>${escapeHtml(s.dominant_hour_of_day ?? '—')}</td><td>${escapeHtml((s.time_span_seconds ?? 0).toFixed ? (s.time_span_seconds ?? 0).toFixed(1) : (s.time_span_seconds ?? 0))}</td>`;
        row.addEventListener('click', () => {
          const input = document.getElementById('profiles-entity-id');
          if (input) input.value = s.entity_id;
          renderEntityProfileDetail(data, s.entity_id);
        });
        table.appendChild(row);
      });
    }

    function renderEntityProfileDetail(data, entityId) {
      const pre = document.getElementById('profiles-detail');
      const raw = document.getElementById('profiles-detail-raw');
      if (!pre) return;
      const entities = data?.entities || [];
      const found = entities.find(e => e.entity_id === entityId);
      if (!found) {
        pre.textContent = `Entity not found: ${entityId}`;
        if (raw) raw.textContent = '—';
        return;
      }
      // Keep detail concise.
      const obs = (found.observations || []).slice(0, 20);
      const total = (found.observations || []).length;
      const cameras = [...new Set((found.observations || []).map(o => o.camera_id).filter(Boolean))].slice(0, 6);
      pre.innerHTML = `<div class="nl">
        <div class="k">Entity</div>
        <div class="v">${escapeHtml(found.entity_id || '—')}</div>
        <ul class="nl-list">
          <li>Track: ${escapeHtml(found.track_id || '—')}</li>
          <li>Observations: ${total} (showing ${obs.length})</li>
          <li>Cameras: ${escapeHtml(cameras.length ? cameras.join(', ') : '—')}</li>
        </ul>
        <div class="k" style="margin-top:10px;">Recent observations</div>
        <table class="table" style="margin-top:6px;">
          <tr><th>Time</th><th>Camera</th><th>Note</th></tr>
          ${obs.map(o => {
            const t = o.ts_ms ? new Date(o.ts_ms).toLocaleString() : '—';
            return `<tr><td>${escapeHtml(t)}</td><td>${escapeHtml(o.camera_id || '—')}</td><td>${escapeHtml(o.note || '—')}</td></tr>`;
          }).join('')}
        </table>
      </div>`;
      if (raw) raw.textContent = JSON.stringify(found, null, 2);
    }

    function renderIntelCasebookSkeleton() {
      const grid = document.getElementById('intel-casebook');
      if (!grid) return;
      grid.innerHTML = '';
      const actions = document.createElement('div');
      actions.className = 'card';
      actions.innerHTML = `<h3>${intelTabs.casebook.title}</h3>
        <p class="muted">${intelTabs.casebook.desc}</p>
        <div class="toolbar"><button class="pill-button" id="casebook-refresh">Refresh</button></div>
        <div id="casebook-meta" class="muted">Loading...</div>`;

      const createCase = document.createElement('div');
      createCase.className = 'card';
      createCase.innerHTML = `<h3>Create Case</h3>
        <div class="status-row"><span class="muted small">Title</span><input type="text" id="case-title" placeholder="e.g., Night perimeter anomaly" /></div>
        <div class="status-row"><span class="muted small">Domain</span><input type="text" id="case-domain" value="facility" /></div>
        <div class="status-row"><span class="muted small">Description</span></div>
        <textarea id="case-desc" placeholder="short description"></textarea>
        <button class="pill-button" id="case-create">Create</button>
        <pre id="case-create-result">—</pre>`;

      const addEvidence = document.createElement('div');
      addEvidence.className = 'card';
      addEvidence.innerHTML = `<h3>Add Evidence</h3>
        <div class="status-row"><span class="muted small">Kind</span><input type="text" id="ev-kind" value="CCTVClip" /></div>
        <div class="status-row"><span class="muted small">Source</span><input type="text" id="ev-source" value="operator" /></div>
        <div class="status-row"><span class="muted small">URI (optional)</span><input type="text" id="ev-uri" placeholder="file:// or http://" /></div>
        <div class="status-row"><span class="muted small">Case IDs (comma)</span><input type="text" id="ev-case-ids" placeholder="case-..." /></div>
        <div class="status-row"><span class="muted small">Tags (comma)</span><input type="text" id="ev-tags" placeholder="alpr, person" /></div>
        <div class="status-row"><span class="muted small">Description</span></div>
        <textarea id="ev-desc" placeholder="what this evidence is"></textarea>
        <button class="pill-button" id="ev-add">Add</button>
        <pre id="ev-add-result">—</pre>`;

      const createHyp = document.createElement('div');
      createHyp.className = 'card';
      createHyp.innerHTML = `<h3>Create Hypothesis</h3>
        <div class="status-row"><span class="muted small">Title</span><input type="text" id="hyp-title" placeholder="e.g., Tailgating attempt" /></div>
        <div class="status-row"><span class="muted small">Confidence</span><input type="number" id="hyp-conf" min="0" max="1" step="0.05" value="0.3" /></div>
        <div class="status-row"><span class="muted small">Case IDs (comma)</span><input type="text" id="hyp-case-ids" placeholder="case-..." /></div>
        <div class="status-row"><span class="muted small">Evidence IDs (comma)</span><input type="text" id="hyp-ev-ids" placeholder="ev-..." /></div>
        <div class="status-row"><span class="muted small">Description</span></div>
        <textarea id="hyp-desc" placeholder="hypothesis statement"></textarea>
        <div class="status-row"><span class="muted small">Rationale</span></div>
        <textarea id="hyp-rationale" placeholder="why you believe this"></textarea>
        <button class="pill-button" id="hyp-create">Create</button>
        <pre id="hyp-create-result">—</pre>`;

      const view = document.createElement('div');
      view.className = 'card';
      view.innerHTML = `<h3>Casebook (readable)</h3>
        <div class="muted">A human-friendly view of cases, evidence, and hypotheses.</div>
        <div id="casebook-readable" style="margin-top:10px;">
          <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));">
            <div class="card" style="box-shadow:none;border:1px solid rgba(255,255,255,0.06);">
              <strong>Cases</strong>
              <div class="muted small">Select one to see details.</div>
              <div id="casebook-cases" style="margin-top:8px;"></div>
            </div>
            <div class="card" style="box-shadow:none;border:1px solid rgba(255,255,255,0.06);">
              <strong>Selected case</strong>
              <div id="casebook-selected" class="muted" style="margin-top:8px;">—</div>
            </div>
            <div class="card" style="box-shadow:none;border:1px solid rgba(255,255,255,0.06);">
              <strong>Evidence</strong>
              <div id="casebook-evidence" class="muted" style="margin-top:8px;">—</div>
            </div>
            <div class="card" style="box-shadow:none;border:1px solid rgba(255,255,255,0.06);">
              <strong>Hypotheses</strong>
              <div id="casebook-hypotheses" class="muted" style="margin-top:8px;">—</div>
            </div>
          </div>
        </div>
        <details style="margin-top:10px;">
          <summary class="muted" style="cursor:pointer;">Raw JSON (advanced)</summary>
          <pre id="casebook-json">Waiting...</pre>
        </details>`;

      grid.appendChild(actions);
      grid.appendChild(createCase);
      grid.appendChild(addEvidence);
      grid.appendChild(createHyp);
      grid.appendChild(view);

      document.getElementById('casebook-refresh')?.addEventListener('click', () => loadCasebook(true));
      document.getElementById('case-create')?.addEventListener('click', async () => {
        const title = document.getElementById('case-title')?.value || 'Untitled';
        const domain = document.getElementById('case-domain')?.value || 'facility';
        const description = document.getElementById('case-desc')?.value || '';
        await casebookPost({ op: 'create_case', title, domain, description }, 'case-create-result');
        loadCasebook(true);
      });
      document.getElementById('ev-add')?.addEventListener('click', async () => {
        const kind = document.getElementById('ev-kind')?.value || 'Evidence';
        const source = document.getElementById('ev-source')?.value || 'operator';
        const uri = document.getElementById('ev-uri')?.value || null;
        const description = document.getElementById('ev-desc')?.value || '';
        const caseIds = (document.getElementById('ev-case-ids')?.value || '').split(',').map(s => s.trim()).filter(Boolean);
        const tags = (document.getElementById('ev-tags')?.value || '').split(',').map(s => s.trim()).filter(Boolean);
        await casebookPost({ op: 'add_evidence', kind, source, uri, description, case_ids: caseIds, tags }, 'ev-add-result');
        loadCasebook(true);
      });
      document.getElementById('hyp-create')?.addEventListener('click', async () => {
        const title = document.getElementById('hyp-title')?.value || 'Hypothesis';
        const confidence = Number(document.getElementById('hyp-conf')?.value || 0.0);
        const description = document.getElementById('hyp-desc')?.value || '';
        const rationale = document.getElementById('hyp-rationale')?.value || '';
        const caseIds = (document.getElementById('hyp-case-ids')?.value || '').split(',').map(s => s.trim()).filter(Boolean);
        const evidenceIds = (document.getElementById('hyp-ev-ids')?.value || '').split(',').map(s => s.trim()).filter(Boolean);
        await casebookPost({ op: 'create_hypothesis', title, description, rationale, confidence, case_ids: caseIds, evidence_ids: evidenceIds }, 'hyp-create-result');
        loadCasebook(true);
      });
    }

    async function casebookPost(payload, resultElId) {
      const out = document.getElementById(resultElId);
      if (out) out.textContent = 'Sending...';
      try {
        if (demoMode) {
          const demo = getDemoState();
          const op = String(payload?.op || '').trim();
          if (!demo.casebook) demo.casebook = { schema_version: '0.1', cases: [], evidence: [], hypotheses: [] };

          if (op === 'create_case') {
            const created = {
              id: demoId('case'),
              title: String(payload.title || 'Untitled'),
              description: String(payload.description || ''),
              status: 'open',
              opened_at: Math.floor(Date.now() / 1000),
              domain: String(payload.domain || 'facility'),
              classification: 'CUI',
            };
            demo.casebook.cases.unshift(created);
            if (out) out.textContent = JSON.stringify({ ok: true, case: created, demo: true }, null, 2);
            renderCasebookReadable(demo.casebook);
            const pre = document.getElementById('casebook-json');
            if (pre) pre.textContent = JSON.stringify(demo.casebook, null, 2);
            return;
          }
          if (op === 'add_evidence') {
            const created = {
              id: demoId('evidence'),
              kind: String(payload.kind || 'Evidence'),
              description: String(payload.description || ''),
              source: String(payload.source || 'operator'),
              created_at: Math.floor(Date.now() / 1000),
              uri: payload.uri || null,
              case_ids: Array.isArray(payload.case_ids) ? payload.case_ids : [],
              tags: Array.isArray(payload.tags) ? payload.tags : [],
              classification: 'CUI',
            };
            demo.casebook.evidence.unshift(created);
            if (out) out.textContent = JSON.stringify({ ok: true, evidence: created, demo: true }, null, 2);
            renderCasebookReadable(demo.casebook);
            const pre = document.getElementById('casebook-json');
            if (pre) pre.textContent = JSON.stringify(demo.casebook, null, 2);
            return;
          }
          if (op === 'create_hypothesis') {
            const created = {
              id: demoId('hyp'),
              title: String(payload.title || 'Hypothesis'),
              description: String(payload.description || ''),
              status: 'open',
              confidence: Number(payload.confidence || 0.0),
              rationale: String(payload.rationale || ''),
              created_at: Math.floor(Date.now() / 1000),
              updated_at: Math.floor(Date.now() / 1000),
              case_ids: Array.isArray(payload.case_ids) ? payload.case_ids : [],
              evidence_ids: Array.isArray(payload.evidence_ids) ? payload.evidence_ids : [],
              classification: 'CUI',
            };
            demo.casebook.hypotheses.unshift(created);
            if (out) out.textContent = JSON.stringify({ ok: true, hypothesis: created, demo: true }, null, 2);
            renderCasebookReadable(demo.casebook);
            const pre = document.getElementById('casebook-json');
            if (pre) pre.textContent = JSON.stringify(demo.casebook, null, 2);
            return;
          }

          if (out) out.textContent = JSON.stringify({ ok: false, error: `unknown op: ${op}`, demo: true }, null, 2);
          return;
        }

        const res = await fetch('/api/casebook', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data?.error || 'request failed');
        if (out) out.textContent = JSON.stringify(data, null, 2);
      } catch (e) {
        if (out) out.textContent = `Failed: ${e.message || e}`;
      }
    }

    async function loadCasebook(force = false) {
      try {
        if (demoMode) {
          const demo = getDemoState();
          const meta = document.getElementById('casebook-meta');
          const pre = document.getElementById('casebook-json');
          if (meta) meta.textContent = `Demo casebook: ${demo.casebook.cases.length} case(s) · ${demo.casebook.evidence.length} evidence item(s) · ${demo.casebook.hypotheses.length} hypothesis/hypotheses.`;
          if (pre) pre.textContent = JSON.stringify(demo.casebook, null, 2);
          renderCasebookReadable(demo.casebook);
          return;
        }

        const res = await fetch('/api/casebook', { cache: force ? 'reload' : 'default' });
        if (!res.ok) throw new Error('casebook unavailable');
        const data = await res.json();
        const meta = document.getElementById('casebook-meta');
        const pre = document.getElementById('casebook-json');
        if (meta) meta.textContent = `${(data?.cases || []).length} case(s) · ${(data?.evidence || []).length} evidence item(s) · ${(data?.hypotheses || []).length} hypothesis/hypotheses.`;
        if (pre) pre.textContent = JSON.stringify(data, null, 2);
        renderCasebookReadable(data);
      } catch (e) {
        const meta = document.getElementById('casebook-meta');
        const pre = document.getElementById('casebook-json');
        if (meta) meta.textContent = demoMode ? 'Demo casebook unavailable.' : 'Casebook not found yet. It will be created automatically after your first create/add action.';
        if (pre) pre.textContent = '—';
        renderCasebookReadable(null);
      }
    }

    function renderCasebookReadable(data) {
      const casesEl = document.getElementById('casebook-cases');
      const selectedEl = document.getElementById('casebook-selected');
      const evidenceEl = document.getElementById('casebook-evidence');
      const hypsEl = document.getElementById('casebook-hypotheses');
      if (!casesEl || !selectedEl || !evidenceEl || !hypsEl) return;

      if (!data) {
        casesEl.innerHTML = '<div class="muted">No casebook loaded yet.</div>';
        selectedEl.textContent = '—';
        evidenceEl.textContent = '—';
        hypsEl.textContent = '—';
        return;
      }

      const cases = Array.isArray(data.cases) ? data.cases : [];
      const evidence = Array.isArray(data.evidence) ? data.evidence : [];
      const hypotheses = Array.isArray(data.hypotheses) ? data.hypotheses : [];

      if (!window.__casebookSelectedId && cases.length) window.__casebookSelectedId = cases[0].id;
      if (cases.length && !cases.find(c => c.id === window.__casebookSelectedId)) window.__casebookSelectedId = cases[0].id;

      casesEl.innerHTML = '';
      if (!cases.length) {
        casesEl.innerHTML = '<div class="muted">No cases yet. Create one on the left.</div>';
      } else {
        cases.slice(0, 10).forEach(c => {
          const btn = document.createElement('button');
          btn.className = 'pill-button';
          btn.style.width = '100%';
          btn.style.marginBottom = '8px';
          btn.style.border = '1px solid rgba(255,255,255,0.12)';
          btn.style.background = window.__casebookSelectedId === c.id ? 'rgba(76,240,181,0.16)' : 'rgba(255,255,255,0.05)';
          btn.style.color = 'var(--text)';
          btn.textContent = `${c.title || c.id} (${c.status || 'open'})`;
          btn.addEventListener('click', () => {
            window.__casebookSelectedId = c.id;
            renderCasebookReadable(data);
          });
          casesEl.appendChild(btn);
        });
      }

      const selected = cases.find(c => c.id === window.__casebookSelectedId) || cases[0] || null;
      if (!selected) {
        selectedEl.textContent = 'No case selected.';
        evidenceEl.textContent = '—';
        hypsEl.textContent = '—';
        return;
      }

      const opened = selected.opened_at ? new Date(selected.opened_at * 1000).toLocaleString() : '—';
      selectedEl.innerHTML = `
        <div><strong>${selected.title || selected.id}</strong></div>
        <div class="muted small">Domain: ${selected.domain || '—'} · Classification: ${selected.classification || '—'} · Opened: ${opened}</div>
        <div style="margin-top:8px;">${(selected.description || '').trim() || '<span class="muted">No description.</span>'}</div>
      `;

      const evForCase = evidence.filter(ev => (ev.case_ids || []).includes(selected.id));
      const hypForCase = hypotheses.filter(h => (h.case_ids || []).includes(selected.id));

      if (!evForCase.length) {
        evidenceEl.innerHTML = '<div class="muted">No evidence linked to this case yet.</div>';
      } else {
        evidenceEl.innerHTML = evForCase.slice(0, 10).map(ev => {
          const when = ev.created_at ? new Date(ev.created_at * 1000).toLocaleString() : '—';
          const tags = (ev.tags || []).length ? ` · Tags: ${(ev.tags || []).join(', ')}` : '';
          const uri = ev.uri ? ` · URI: ${ev.uri}` : '';
          return `<div style="margin-bottom:10px;">
            <div><strong>${ev.kind || 'Evidence'}</strong> — ${(ev.description || '').trim() || '—'}</div>
            <div class="muted small">${when} · Source: ${ev.source || '—'}${tags}${uri}</div>
          </div>`;
        }).join('');
      }

      if (!hypForCase.length) {
        hypsEl.innerHTML = '<div class="muted">No hypotheses for this case yet.</div>';
      } else {
        hypsEl.innerHTML = hypForCase.slice(0, 10).map(h => {
          const conf = (h.confidence ?? 0);
          const pct = (typeof conf === 'number' && isFinite(conf)) ? Math.round(conf * 100) : '—';
          const updated = h.updated_at ? new Date(h.updated_at * 1000).toLocaleString() : '—';
          const status = h.status || 'open';
          return `<div style="margin-bottom:10px;">
            <div><strong>${h.title || h.id}</strong> (${status}, ${pct}% confidence)</div>
            <div style="margin-top:6px;">${(h.description || '').trim() || '<span class="muted">No description.</span>'}</div>
            <div class="muted small" style="margin-top:6px;">Updated: ${updated}</div>
            ${h.rationale ? `<div class="muted small" style="margin-top:6px;">Rationale: ${h.rationale}</div>` : ''}
          </div>`;
        }).join('');
      }
    }

    function renderIntelEnhanceSkeleton() {
      const grid = document.getElementById('intel-enhance');
      if (!grid) return;
      grid.innerHTML = '';
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `<h3>${intelTabs.enhance.title}</h3>
        <p class="muted">${intelTabs.enhance.desc} Provide a server-local path to a video file (e.g., under the workspace).</p>
        <div class="status-row"><span class="muted small">Video path</span><input id="enh-video" type="text" placeholder="/workspaces/.../some.mp4" /></div>
        <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));">
          <div class="card" style="box-shadow:none;border:1px solid rgba(255,255,255,0.06);">
            <div class="status-row"><span class="muted small">Deinterlace</span><input id="enh-deint" type="text" value="false" /></div>
            <div class="status-row"><span class="muted small">Stabilize</span><input id="enh-stab" type="text" value="true" /></div>
            <div class="status-row"><span class="muted small">Redact faces</span><input id="enh-redact" type="text" value="false" /></div>
          </div>
          <div class="card" style="box-shadow:none;border:1px solid rgba(255,255,255,0.06);">
            <div class="status-row"><span class="muted small">Denoise window</span><input id="enh-denoise" type="number" value="2" min="0" max="8" /></div>
            <div class="status-row"><span class="muted small">Sharpen amount</span><input id="enh-sharp" type="number" value="0.8" step="0.1" min="0" max="2" /></div>
            <div class="status-row"><span class="muted small">SR scale</span><input id="enh-scale" type="number" value="2" min="1" max="4" /></div>
          </div>
          <div class="card" style="box-shadow:none;border:1px solid rgba(255,255,255,0.06);">
            <div class="status-row"><span class="muted small">Max frames</span><input id="enh-max" type="number" value="120" min="1" max="5000" /></div>
            <div class="muted small">Tip: keep max frames small for quick runs.</div>
          </div>
        </div>
        <button class="pill-button" id="enh-run">Run Enhancement</button>
        <pre id="enh-result">—</pre>
        <div id="enh-artifacts"></div>`;
      grid.appendChild(card);

      document.getElementById('enh-run')?.addEventListener('click', async () => {
        const video_path = document.getElementById('enh-video')?.value?.trim();
        if (!video_path) return alert('Provide a server-local video path.');
        const cfg = {
          deinterlace: (document.getElementById('enh-deint')?.value || 'false') === 'true',
          stabilize: (document.getElementById('enh-stab')?.value || 'true') === 'true',
          redact_faces: (document.getElementById('enh-redact')?.value || 'false') === 'true',
          denoise_window: Number(document.getElementById('enh-denoise')?.value || 2),
          sharpen_amount: Number(document.getElementById('enh-sharp')?.value || 0.8),
          sr_scale: Number(document.getElementById('enh-scale')?.value || 2),
          max_frames: Number(document.getElementById('enh-max')?.value || 120),
        };
        await runEnhancement(video_path, cfg);
      });
    }

    async function runEnhancement(video_path, config) {
      const pre = document.getElementById('enh-result');
      const artifacts = document.getElementById('enh-artifacts');
      if (pre) pre.textContent = 'Running...';
      if (artifacts) artifacts.innerHTML = '';
      try {
        const res = await fetch('/api/enhance', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ video_path, config }),
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data?.detail || data?.error || 'enhancement failed');
        if (pre) pre.textContent = JSON.stringify(data.result, null, 2);

        const urls = data?.result?.artifact_urls || {};
        const paths = data?.result?.artifact_paths || {};
        if (artifacts) {
          const card = document.createElement('div');
          card.className = 'card';
          card.innerHTML = `<h3>Artifacts</h3>
            <div class="status-row"><span>Video</span><span class="muted small">${paths.video || '—'}</span></div>
            <div class="status-row"><span>Montage</span><span class="muted small">${paths.montage || '—'}</span></div>
            <div class="status-row"><span>Metadata</span><span class="muted small">${paths.metadata || '—'}</span></div>
            <div style="display:flex;gap:10px;flex-wrap:wrap;">
              ${urls.video ? `<a class="link" href="${urls.video}" target="_blank">Open video</a>` : ''}
              ${urls.montage ? `<a class="link" href="${urls.montage}" target="_blank">Open montage</a>` : ''}
              ${urls.metadata ? `<a class="link" href="${urls.metadata}" target="_blank">Open metadata</a>` : ''}
            </div>
            ${urls.montage ? `<div style="margin-top:10px;"><img src="${urls.montage}" style="max-width:100%;border-radius:12px;border:1px solid rgba(255,255,255,0.08);" /></div>` : ''}
            ${urls.video ? `<div style="margin-top:10px;"><video controls style="width:100%;border-radius:12px;border:1px solid rgba(255,255,255,0.08);" src="${urls.video}"></video></div>` : ''}`;
          artifacts.appendChild(card);
        }
      } catch (e) {
        if (pre) pre.textContent = `Failed: ${e.message || e}`;
      }
    }

    // -------------------- Graph Query (state) --------------------
    // Initialized early so the Graph tab can reference it.
    let __heliosGraphQuery = {
      active: false,
      queryText: '',
      result: null,
      error: null,
    };

    function renderIntelGraphSkeleton() {
      const grid = document.getElementById('intel-graph');
      if (!grid) return;
      grid.innerHTML = '';

      const info = document.createElement('div');
      info.className = 'card';
      info.innerHTML = `<h3>${intelTabs.graph.title}</h3>
        <p class="muted">${intelTabs.graph.desc}</p>
        <div class="toolbar">
          <button class="pill-button" id="graph-refresh">Refresh</button>
            <span class="pill">View</span>
            <button class="pill-button" id="graph-view-browse" title="Browse/search view">Browse</button>
            <button class="pill-button" id="graph-view-query" title="Query DSL view">Query</button>
        </div>
        <div id="graph-meta" class="muted">Loading...</div>
        <details class="nl-raw"><summary>Raw JSON (advanced)</summary><pre id="graph-raw">—</pre></details>`;

      const browse = document.createElement('div');
      browse.className = 'card';
      browse.innerHTML = `<h3>Browse</h3>
        <div class="status-row"><span class="muted small">Search</span><input id="graph-search" type="text" placeholder="node id / label / type" /></div>
        <div class="toolbar">
          <button class="pill-button" id="graph-clear">Clear</button>
        </div>
          <div class="muted small">Shows first 50 matching nodes and edges.</div>
          <hr style="border:none;border-top:1px solid rgba(255,255,255,0.08);margin:12px 0;" />
          <h3 style="margin-top:0;">Query DSL</h3>
          <p class="muted">Filter, traverse, and path-find over the ontology graph. Run a query, then switch View → Query to drive tables and highlighting.</p>
          <div class="status-row"><span class="muted small">Preset</span>
            <select id="graph-q-preset" style="width:100%"></select>
          </div>
          <div class="status-row"><span class="muted small">Query</span>
            <textarea id="graph-q" rows="6" style="width:100%;resize:vertical" placeholder="nodes where type=event and props.severity=critical"></textarea>
          </div>
          <div class="toolbar" style="flex-wrap:wrap;gap:10px;">
            <button class="pill-button" id="graph-q-run">Run Query</button>
            <button class="pill-button" id="graph-q-clear">Clear</button>
            <button class="pill-button" id="graph-q-use">Use Results</button>
            <button class="pill-button" id="graph-q-export">Export JSON</button>
          </div>
          <div class="status-row" style="margin-top:8px;"><span class="muted small">Save as</span>
            <input id="graph-q-name" type="text" placeholder="name (optional)" />
          </div>
          <div class="toolbar" style="flex-wrap:wrap;gap:10px;">
            <button class="pill-button" id="graph-q-save">Save</button>
            <button class="pill-button" id="graph-q-delete">Delete</button>
            <span class="pill">Tip: start with “neighbors where …”</span>
          </div>
          <pre id="graph-q-status" style="white-space:pre-wrap;">—</pre>
          <details class="nl-raw"><summary>Query DSL help</summary>
            <pre style="white-space:pre-wrap;">Statements:
  nodes where <expr>
  edges where <expr>
  neighbors where <node-expr> depth <n> dir (in|out|both) edge where <edge-expr>
  path from <node-expr> to <node-expr> max <n> dir (in|out|both) edge where <edge-expr>

Expr operators:
  and, or, not, parentheses
  =, !=, >, >=, <, <=, ~ (contains), in (a,b,c)

Fields:
  Node: id, type, label, props.<key>
  Edge: source, target, type, props.<key>

Examples:
  nodes where type=event and props.severity=critical
  neighbors where type=event depth 2 dir both
  path from type=task to type=case max 6 dir both
  edges where type=SUPPORTED_BY
            </pre>
          </details>`;

      const viz = document.createElement('div');
      viz.className = 'card';
      viz.innerHTML = `<h3>Relational View</h3>
        <p class="muted">An illustrative relationship map (hover nodes, click to focus). Uses the same graph data as the tables.</p>
        <div class="toolbar">
          <button class="pill-button" id="graph-viz-fit">Fit / Reset</button>
          <button class="pill-button" id="graph-viz-pause">Pause</button>
          <span class="pill">Tip: type in Search to focus</span>
        </div>
        <div class="toolbar" id="graph-viz-filters" style="margin-top:8px;gap:10px;flex-wrap:wrap;"></div>
        <canvas id="graph-viz" class="graph-viz" height="360"></canvas>
        <div id="graph-viz-tip" class="graph-viz-tip">Hover a node to see details. Click a node to filter tables.</div>
        <div id="graph-viz-legend" class="graph-viz-legend"></div>`;

      const nodesCard = document.createElement('div');
      nodesCard.className = 'card';
      nodesCard.innerHTML = `<h3>Nodes</h3><table class="table" id="graph-nodes"></table>`;

      const edgesCard = document.createElement('div');
      edgesCard.className = 'card';
      edgesCard.innerHTML = `<h3>Edges</h3><table class="table" id="graph-edges"></table>`;

      grid.appendChild(info);
      grid.appendChild(browse);
      grid.appendChild(viz);
      grid.appendChild(nodesCard);
      grid.appendChild(edgesCard);

        document.getElementById('graph-refresh')?.addEventListener('click', () => loadGraph(true));

        document.getElementById('graph-view-browse')?.addEventListener('click', () => {
          setGraphViewMode('browse');
          renderGraph(window.__heliosGraph || null);
        });
        document.getElementById('graph-view-query')?.addEventListener('click', () => {
          setGraphViewMode('query');
          renderGraph(window.__heliosGraph || null);
        });
      document.getElementById('graph-clear')?.addEventListener('click', () => {
        const input = document.getElementById('graph-search');
        if (input) input.value = '';
        renderGraph(window.__heliosGraph || null);
      });
      document.getElementById('graph-search')?.addEventListener('input', () => {
        renderGraph(window.__heliosGraph || null);
      });

      document.getElementById('graph-viz-fit')?.addEventListener('click', () => {
        try { resetGraphViz(window.__heliosGraph || null); } catch (_) {}
      });
      document.getElementById('graph-viz-pause')?.addEventListener('click', (ev) => {
        const btn = ev?.target;
        const paused = toggleGraphVizPaused();
        if (btn && btn.textContent) btn.textContent = paused ? 'Resume' : 'Pause';
      });

        // Query UI setup (best-effort)
        try { initGraphQueryUI(); } catch (_) {}
    }

    async function loadGraph(force = false) {
      try {
        if (demoMode) {
          const demo = getDemoState();
          window.__heliosGraph = demo.graph;
          renderGraph(demo.graph);
          return;
        }
        const res = await fetch('/api/graph', { cache: force ? 'reload' : 'default' });
        const data = await res.json();
        if (!res.ok) throw new Error(data?.detail || data?.error || 'graph unavailable');
        window.__heliosGraph = data;
        renderGraph(data);
      } catch (e) {
        window.__heliosGraph = null;
        const meta = document.getElementById('graph-meta');
        const nodes = document.getElementById('graph-nodes');
        const edges = document.getElementById('graph-edges');
        if (meta) meta.textContent = `Graph not available yet. Run the pipeline or create casebook items to generate out/graph.json. (${e.message || e})`;
        if (nodes) nodes.innerHTML = '<tr><td class="muted">No nodes.</td></tr>';
        if (edges) edges.innerHTML = '<tr><td class="muted">No edges.</td></tr>';
      }
    }

    function renderGraph(graph) {
      const meta = document.getElementById('graph-meta');
      const nodesTable = document.getElementById('graph-nodes');
      const edgesTable = document.getElementById('graph-edges');
      const raw = document.getElementById('graph-raw');
      if (!meta || !nodesTable || !edgesTable) return;

      if (!graph) {
        meta.textContent = 'No graph loaded.';
        nodesTable.innerHTML = '<tr><td class="muted">No nodes.</td></tr>';
        edgesTable.innerHTML = '<tr><td class="muted">No edges.</td></tr>';
        stopGraphViz();
        return;
      }

      const q = (document.getElementById('graph-search')?.value || '').trim().toLowerCase();
      const viewMode = getGraphViewMode();

      const baseNodes = Array.isArray(graph.nodes) ? graph.nodes : [];
      const baseEdges = Array.isArray(graph.edges) ? graph.edges : [];

      const queryNodes = Array.isArray(__heliosGraphQuery?.result?.nodes) ? __heliosGraphQuery.result.nodes : null;
      const queryEdges = Array.isArray(__heliosGraphQuery?.result?.edges) ? __heliosGraphQuery.result.edges : null;
      const useQuery = (viewMode === 'query') && !!queryNodes && !!queryEdges;

      const nodes = useQuery ? queryNodes : baseNodes;
      const edges = useQuery ? queryEdges : baseEdges;

        const availableTypes = (graph?.stats?.node_types && Array.isArray(graph.stats.node_types))
          ? graph.stats.node_types
          : [...new Set(baseNodes.map(n => n?.type).filter(Boolean))];
      const allowedTypes = __heliosGraphViz.filterTypes || _getTypeFilterSet(availableTypes);

      const generatedAt = graph.generated_at ? new Date(graph.generated_at).toLocaleString() : '—';
      const nodeTypes = graph?.stats?.node_types || [];
      const edgeTypes = graph?.stats?.edge_types || [];
      const sourceLabel = demoMode ? 'Demo Data (seeded)' : 'Live API (/api/graph)';
        const queryKind = String(__heliosGraphQuery?.result?.meta?.kind || 'query');
        const queryBadge = useQuery ? ` · Query view (${queryKind})` : (viewMode === 'query' ? ' · Query view (no results yet)' : '');
      meta.innerHTML = `<div class="nl">
        <div class="k">What this is</div>
        <div class="v">A relationship map between events, actions, cases, evidence, and entities</div>
        <ul class="nl-list">
          <li>Generated: ${escapeHtml(generatedAt)}</li>
          <li>${nodes.length} nodes (${escapeHtml(nodeTypes.length ? nodeTypes.join(', ') : 'types unknown')})</li>
          <li>${edges.length} edges (${escapeHtml(edgeTypes.length ? edgeTypes.join(', ') : 'types unknown')})</li>
            <li>Source: ${escapeHtml(sourceLabel)}${escapeHtml(queryBadge)}</li>
        </ul>
      </div>`;
      if (raw) raw.textContent = JSON.stringify(graph, null, 2);

      const nodeMatches = (n) => {
        if (!q) return true;
        const hay = `${n.id || ''} ${n.type || ''} ${n.label || ''}`.toLowerCase();
        return hay.includes(q);
      };
      const edgeMatches = (e) => {
        if (!q) return true;
        const hay = `${e.source || ''} ${e.type || ''} ${e.target || ''}`.toLowerCase();
        return hay.includes(q);
      };

      const nodesById = new Map(nodes.map(n => [String(n.id), n]));

      const viewNodes = nodes
        .filter(n => allowedTypes.has(String(n.type || '')))
        .filter(nodeMatches)
        .slice(0, 50);

      const viewEdges = edges
        .filter(e => {
          const s = String(e.source || '');
          const t = String(e.target || '');
          const sn = nodesById.get(s);
          const tn = nodesById.get(t);
          if (sn && !allowedTypes.has(String(sn.type || ''))) return false;
          if (tn && !allowedTypes.has(String(tn.type || ''))) return false;
          return true;
        })
        .filter(edgeMatches)
        .slice(0, 50);

      // Keep the UI intact: tables remain authoritative; the viz is illustrative.
      try { renderGraphViz(graph); } catch (e) { /* best effort */ }

      if (!viewNodes.length) {
        nodesTable.innerHTML = '<tr><td class="muted">No matching nodes.</td></tr>';
      } else {
        nodesTable.innerHTML = '<tr><th>ID</th><th>Type</th><th>Label</th></tr>';
        viewNodes.forEach(n => {
          const row = document.createElement('tr');
          row.style.cursor = 'pointer';
          row.innerHTML = `<td>${escapeHtml(n.id || '—')}</td><td>${escapeHtml(n.type || '—')}</td><td>${escapeHtml(n.label || '—')}</td>`;
          row.addEventListener('click', () => {
            const input = document.getElementById('graph-search');
            if (input) input.value = (n.id || '').toString();
            renderGraph(graph);
          });
          nodesTable.appendChild(row);
        });
      }

      if (!viewEdges.length) {
        edgesTable.innerHTML = '<tr><td class="muted">No matching edges.</td></tr>';
      } else {
        edgesTable.innerHTML = '<tr><th>Source</th><th>Type</th><th>Target</th></tr>';
        viewEdges.forEach(e => {
          const row = document.createElement('tr');
          row.innerHTML = `<td>${escapeHtml(e.source || '—')}</td><td>${escapeHtml(e.type || '—')}</td><td>${escapeHtml(e.target || '—')}</td>`;
          edgesTable.appendChild(row);
        });
      }
    }

    // -------------------- Graph Query DSL --------------------
    function _graphViewModeKey() { return 'helios_graph_view_mode'; }
    function _graphSavedQueriesKey() { return 'helios_graph_saved_queries_v1'; }

    function getGraphViewMode() {
      try {
        const v = (localStorage.getItem(_graphViewModeKey()) || '').trim();
        return (v === 'query' || v === 'browse') ? v : 'browse';
      } catch (_) {
        return 'browse';
      }
    }

    function setGraphViewMode(mode) {
      const m = (mode === 'query') ? 'query' : 'browse';
      try { localStorage.setItem(_graphViewModeKey(), m); } catch (_) {}
      const b1 = document.getElementById('graph-view-browse');
      const b2 = document.getElementById('graph-view-query');
      if (b1) b1.style.opacity = (m === 'browse') ? '1' : '0.65';
      if (b2) b2.style.opacity = (m === 'query') ? '1' : '0.65';
    }

    function _loadSavedQueries() {
      try {
        const raw = localStorage.getItem(_graphSavedQueriesKey());
        if (!raw) return {};
        const obj = JSON.parse(raw);
        return (obj && typeof obj === 'object') ? obj : {};
      } catch (_) {
        return {};
      }
    }

    function _saveSavedQueries(obj) {
      try { localStorage.setItem(_graphSavedQueriesKey(), JSON.stringify(obj)); } catch (_) {}
    }

    function _builtinQueryPresets() {
      return {
        'Critical events': 'nodes where type=event and props.severity=critical',
        'Evidence links': 'edges where type=SUPPORTED_BY or type=EVIDENCE_FOR',
        'Expand around events (2 hops)': 'neighbors where type=event depth 2 dir both',
        'Task → Case path': 'path from type=task to type=case max 6 dir both',
        'All tasks pending': 'nodes where type=task_pending',
      };
    }

    function _setQueryStatus(text) {
      const pre = document.getElementById('graph-q-status');
      if (pre) pre.textContent = text || '—';
    }

    function initGraphQueryUI() {
      const presetSel = document.getElementById('graph-q-preset');
      const textarea = document.getElementById('graph-q');
      const nameInput = document.getElementById('graph-q-name');
      if (!presetSel || !textarea) return;

      const rebuildPresets = () => {
        const builtins = _builtinQueryPresets();
        const saved = _loadSavedQueries();
        presetSel.innerHTML = '';

        const addOpt = (label, value) => {
          const o = document.createElement('option');
          o.value = value;
          o.textContent = label;
          presetSel.appendChild(o);
        };

        addOpt('— Built-in presets —', '__builtin__');
        Object.entries(builtins).forEach(([k, v]) => addOpt(k, v));
        addOpt('— Saved queries —', '__saved__');
        Object.keys(saved).sort().forEach(k => addOpt(k, `__saved__:${k}`));
      };

      rebuildPresets();

      presetSel.addEventListener('change', () => {
        const v = presetSel.value;
        const builtins = _builtinQueryPresets();
        const saved = _loadSavedQueries();
        if (v === '__builtin__' || v === '__saved__') return;
        if (v.startsWith('__saved__:')) {
          const name = v.slice('__saved__:'.length);
          const q = saved[name];
          if (typeof q === 'string') {
            textarea.value = q;
            if (nameInput) nameInput.value = name;
          }
          return;
        }
        // Otherwise the value is the query itself (built-in).
        const isBuiltinQuery = Object.values(builtins).includes(v);
        if (isBuiltinQuery) {
          textarea.value = v;
          if (nameInput) nameInput.value = '';
        }
      });

      document.getElementById('graph-q-clear')?.addEventListener('click', () => {
        textarea.value = '';
        __heliosGraphQuery = { active: false, queryText: '', result: null, error: null };
        __heliosGraphViz.queryHighlightIds = null;
        __heliosGraphViz.queryHighlightEdgeKeys = null;
        _setQueryStatus('—');
        renderGraph(window.__heliosGraph || null);
      });

      document.getElementById('graph-q-run')?.addEventListener('click', () => {
        runGraphQuery();
      });

      document.getElementById('graph-q-use')?.addEventListener('click', () => {
        if (!__heliosGraphQuery.result) return;
        setGraphViewMode('query');
        renderGraph(window.__heliosGraph || null);
      });

      document.getElementById('graph-q-export')?.addEventListener('click', () => {
        const payload = __heliosGraphQuery.result || null;
        if (!payload) return;
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'graph_query_result.json';
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 250);
      });

      document.getElementById('graph-q-save')?.addEventListener('click', () => {
        const q = (textarea.value || '').trim();
        if (!q) return alert('Nothing to save.');
        const name = (nameInput?.value || '').trim() || `Query ${new Date().toLocaleString()}`;
        const saved = _loadSavedQueries();
        saved[name] = q;
        _saveSavedQueries(saved);
        rebuildPresets();
        _setQueryStatus(`Saved query: ${name}`);
      });

      document.getElementById('graph-q-delete')?.addEventListener('click', () => {
        const name = (nameInput?.value || '').trim();
        if (!name) return alert('Enter the saved query name to delete.');
        const saved = _loadSavedQueries();
        if (!(name in saved)) return alert('No saved query by that name.');
        delete saved[name];
        _saveSavedQueries(saved);
        rebuildPresets();
        _setQueryStatus(`Deleted saved query: ${name}`);
      });

      setGraphViewMode(getGraphViewMode());
    }

    function runGraphQuery() {
      const graph = window.__heliosGraph || null;
      const textarea = document.getElementById('graph-q');
      const text = (textarea?.value || '').trim();
      if (!graph) {
        _setQueryStatus('No graph loaded.');
        return;
      }
      if (!text) {
        _setQueryStatus('Enter a query.');
        return;
      }

      try {
        const result = evalGraphDSL(text, graph);
        __heliosGraphQuery = { active: true, queryText: text, result, error: null };

        const ids = new Set((result?.nodes || []).map(n => String(n.id)));
        __heliosGraphViz.queryHighlightIds = ids;
        const edgeKeys = new Set((result?.edges || []).map(e => `${String(e.source)}|${String(e.type)}|${String(e.target)}`));
        __heliosGraphViz.queryHighlightEdgeKeys = edgeKeys;

        const meta = result?.meta || {};
        const lines = [];
        lines.push(`OK: ${meta.kind || 'query'} · nodes=${(result?.nodes || []).length} · edges=${(result?.edges || []).length}`);
        if (meta.note) lines.push(String(meta.note));
        if (meta.found === false) lines.push('No path found.');
        _setQueryStatus(lines.join('\n'));
        renderGraph(graph);
      } catch (e) {
        __heliosGraphQuery = { active: true, queryText: text, result: null, error: String(e?.message || e) };
        __heliosGraphViz.queryHighlightIds = null;
        __heliosGraphViz.queryHighlightEdgeKeys = null;
        _setQueryStatus(`Query error: ${e?.message || e}`);
        renderGraph(graph);
      }
    }

    function evalGraphDSL(text, graph) {
      const tokens = dslTokenize(text);
      const p = new DSLParser(tokens);
      const stmt = p.parseStatement();
      p.expect('EOF');

      const nodes = Array.isArray(graph?.nodes) ? graph.nodes : [];
      const edges = Array.isArray(graph?.edges) ? graph.edges : [];
      const nodeById = new Map(nodes.map(n => [String(n.id), n]));

      const nodePred = (expr) => {
        const fn = compileExpr(expr, 'node');
        return (n) => { try { return !!fn(n); } catch (_) { return false; } };
      };
      const edgePred = (expr) => {
        if (!expr) return (_e) => true;
        const fn = compileExpr(expr, 'edge');
        return (e) => { try { return !!fn(e); } catch (_) { return false; } };
      };

      if (stmt.kind === 'nodes') {
        const pred = nodePred(stmt.where);
        const outNodes = nodes.filter(pred);
        const outIds = new Set(outNodes.map(n => String(n.id)));
        const outEdges = edges.filter(e => outIds.has(String(e.source)) && outIds.has(String(e.target)));
        return { meta: { kind: 'nodes', note: 'Induced subgraph of matching nodes.' }, nodes: outNodes, edges: outEdges };
      }

      if (stmt.kind === 'edges') {
        const pred = edgePred(stmt.where);
        const outEdges = edges.filter(pred);
        const ids = new Set();
        outEdges.forEach(e => { ids.add(String(e.source)); ids.add(String(e.target)); });
        const outNodes = [...ids].map(id => nodeById.get(id)).filter(Boolean);
        return { meta: { kind: 'edges', note: 'Endpoints of matching edges.' }, nodes: outNodes, edges: outEdges };
      }

      // Adjacency for traversal/path
      const outAdj = new Map();
      const inAdj = new Map();
      const addAdj = (m, id, edgeObj) => {
        const k = String(id);
        if (!m.has(k)) m.set(k, []);
        m.get(k).push(edgeObj);
      };
      edges.forEach(e => {
        const eo = { source: String(e.source || ''), target: String(e.target || ''), type: String(e.type || ''), props: e.props || {}, _raw: e };
        addAdj(outAdj, eo.source, eo);
        addAdj(inAdj, eo.target, eo);
      });

      const stepEdges = (nodeId, dir) => {
        const id = String(nodeId);
        if (dir === 'out') return outAdj.get(id) || [];
        if (dir === 'in') return inAdj.get(id) || [];
        return [...(outAdj.get(id) || []), ...(inAdj.get(id) || [])];
      };

      if (stmt.kind === 'neighbors') {
        const startPred = nodePred(stmt.where);
        const starts = nodes.filter(startPred).map(n => String(n.id));
        const dir = stmt.dir || 'both';
        const maxDepth = Math.max(0, Math.min(8, Number(stmt.depth || 1)));
        const ePred = edgePred(stmt.edgeWhere);

        const visited = new Set(starts);
        const q = starts.map(id => ({ id, d: 0 }));
        const keepEdgeKeys = new Set();
        const keepEdges = [];

        while (q.length) {
          const cur = q.shift();
          if (!cur) break;
          if (cur.d >= maxDepth) continue;
          const list = stepEdges(cur.id, dir);
          for (const eo of list) {
            if (!ePred(eo)) continue;
            let nxt = null;
            if (dir === 'out') nxt = eo.target;
            else if (dir === 'in') nxt = eo.source;
            else nxt = (eo.source === cur.id) ? eo.target : eo.source;
            if (!nxt) continue;
            const ek = `${eo.source}|${eo.type}|${eo.target}`;
            if (!keepEdgeKeys.has(ek)) {
              keepEdgeKeys.add(ek);
              keepEdges.push(eo._raw);
            }
            if (!visited.has(nxt)) {
              visited.add(nxt);
              q.push({ id: nxt, d: cur.d + 1 });
            }
          }
        }

        const keepNodes = [...visited].map(id => nodeById.get(id)).filter(Boolean);
        return { meta: { kind: 'neighbors', depth: maxDepth, dir, note: `Expanded from ${starts.length} seed node(s).` }, nodes: keepNodes, edges: keepEdges };
      }

      if (stmt.kind === 'path') {
        const fromPred = nodePred(stmt.from);
        const toPred = nodePred(stmt.to);
        const froms = new Set(nodes.filter(fromPred).map(n => String(n.id)));
        const tos = new Set(nodes.filter(toPred).map(n => String(n.id)));
        const dir = stmt.dir || 'both';
        const maxSteps = Math.max(1, Math.min(12, Number(stmt.max || 6)));
        const ePred = edgePred(stmt.edgeWhere);

        const queue = [];
        const prev = new Map();
        const dist = new Map();
        froms.forEach(id => { queue.push(id); dist.set(id, 0); prev.set(id, null); });

        let found = null;
        while (queue.length) {
          const cur = queue.shift();
          const d = dist.get(cur) || 0;
          if (tos.has(cur)) { found = cur; break; }
          if (d >= maxSteps) continue;
          const list = stepEdges(cur, dir);
          for (const eo of list) {
            if (!ePred(eo)) continue;
            let nxt = null;
            if (dir === 'out') nxt = eo.target;
            else if (dir === 'in') nxt = eo.source;
            else nxt = (eo.source === cur) ? eo.target : eo.source;
            if (!nxt) continue;
            if (dist.has(nxt)) continue;
            dist.set(nxt, d + 1);
            prev.set(nxt, { prevId: cur, edge: eo._raw });
            queue.push(nxt);
          }
        }

        if (!found) {
          return { meta: { kind: 'path', found: false, from_count: froms.size, to_count: tos.size, max: maxSteps, dir }, nodes: [], edges: [] };
        }

        const pathNodes = [];
        const pathEdges = [];
        let cur = found;
        while (cur) {
          pathNodes.push(cur);
          const pr = prev.get(cur);
          if (pr && pr.edge) pathEdges.push(pr.edge);
          cur = pr ? pr.prevId : null;
        }
        pathNodes.reverse();
        pathEdges.reverse();
        const outNodes = pathNodes.map(id => nodeById.get(id)).filter(Boolean);
        return { meta: { kind: 'path', found: true, steps: Math.max(0, pathNodes.length - 1), from_count: froms.size, to_count: tos.size, max: maxSteps, dir }, nodes: outNodes, edges: pathEdges };
      }

      throw new Error(`Unknown statement kind: ${stmt.kind}`);
    }

    function dslTokenize(input) {
      const s = String(input || '');
      const out = [];
      let i = 0;
      const push = (type, value) => out.push({ type, value });

      const isWS = (c) => /\s/.test(c);
      const isIdStart = (c) => /[A-Za-z_]/.test(c);
      const isId = (c) => /[A-Za-z0-9_\.]/.test(c);
      const isNum = (c) => /[0-9]/.test(c);

      while (i < s.length) {
        const c = s[i];
        if (isWS(c)) { i++; continue; }
        if (c === '(' || c === ')' || c === ',') { push(c, c); i++; continue; }
        if (c === '=') { push('OP', '='); i++; continue; }
        if (c === '!' && s[i+1] === '=') { push('OP', '!='); i += 2; continue; }
        if (c === '>' && s[i+1] === '=') { push('OP', '>='); i += 2; continue; }
        if (c === '<' && s[i+1] === '=') { push('OP', '<='); i += 2; continue; }
        if (c === '>') { push('OP', '>'); i++; continue; }
        if (c === '<') { push('OP', '<'); i++; continue; }
        if (c === '~') { push('OP', '~'); i++; continue; }

        if (c === '"' || c === "'") {
          const quote = c;
          i++;
          let val = '';
          while (i < s.length) {
            const ch = s[i];
            if (ch === '\\') {
              const nxt = s[i+1];
              if (nxt) { val += nxt; i += 2; continue; }
            }
            if (ch === quote) { i++; break; }
            val += ch;
            i++;
          }
          push('STRING', val);
          continue;
        }

        if (isNum(c) || (c === '-' && isNum(s[i+1] || ''))) {
          let j = i + 1;
          while (j < s.length && /[0-9\.]/.test(s[j])) j++;
          const raw = s.slice(i, j);
          const num = Number(raw);
          if (!isFinite(num)) throw new Error(`Invalid number: ${raw}`);
          push('NUMBER', num);
          i = j;
          continue;
        }

        if (isIdStart(c)) {
          let j = i + 1;
          while (j < s.length && isId(s[j])) j++;
          const raw = s.slice(i, j);
          push('IDENT', raw);
          i = j;
          continue;
        }

        throw new Error(`Unexpected character: ${c}`);
      }

      push('EOF', 'EOF');
      return out;
    }

    class DSLParser {
      constructor(tokens) {
        this.tokens = tokens || [];
        this.pos = 0;
      }
      peek() { return this.tokens[this.pos] || { type: 'EOF', value: 'EOF' }; }
      next() { const t = this.peek(); this.pos++; return t; }
      match(type, value) {
        const t = this.peek();
        if (t.type !== type) return false;
        if (value !== undefined && String(t.value).toLowerCase() !== String(value).toLowerCase()) return false;
        this.pos++;
        return true;
      }
      expect(type, value) {
        const t = this.next();
        if (t.type !== type) throw new Error(`Expected ${type} but got ${t.type}`);
        if (value !== undefined && String(t.value).toLowerCase() !== String(value).toLowerCase()) {
          throw new Error(`Expected ${value} but got ${t.value}`);
        }
        return t;
      }

      parseStatement() {
        const t = this.peek();
        if (t.type !== 'IDENT') throw new Error('Query must start with nodes/edges/neighbors/path.');
        const kw = String(t.value).toLowerCase();
        this.next();
        if (kw === 'nodes') {
          this.expect('IDENT', 'where');
          const where = this.parseExpr();
          return { kind: 'nodes', where };
        }
        if (kw === 'edges') {
          this.expect('IDENT', 'where');
          const where = this.parseExpr();
          return { kind: 'edges', where };
        }
        if (kw === 'neighbors') {
          this.expect('IDENT', 'where');
          const where = this.parseExpr();
          let depth = 1;
          let dir = 'both';
          let edgeWhere = null;
          while (this.peek().type !== 'EOF') {
            const p = this.peek();
            if (p.type === 'IDENT' && String(p.value).toLowerCase() === 'depth') {
              this.next();
              const n = this.expect('NUMBER');
              depth = n.value;
              continue;
            }
            if (p.type === 'IDENT' && String(p.value).toLowerCase() === 'dir') {
              this.next();
              const d = this.expect('IDENT');
              dir = String(d.value).toLowerCase();
              if (!['in','out','both'].includes(dir)) throw new Error('dir must be in|out|both');
              continue;
            }
            if (p.type === 'IDENT' && String(p.value).toLowerCase() === 'edge') {
              this.next();
              this.expect('IDENT', 'where');
              edgeWhere = this.parseExpr();
              continue;
            }
            break;
          }
          return { kind: 'neighbors', where, depth, dir, edgeWhere };
        }
        if (kw === 'path') {
          this.expect('IDENT', 'from');
          const from = this.parseExpr();
          this.expect('IDENT', 'to');
          const to = this.parseExpr();
          let max = 6;
          let dir = 'both';
          let edgeWhere = null;
          while (this.peek().type !== 'EOF') {
            const p = this.peek();
            if (p.type === 'IDENT' && String(p.value).toLowerCase() === 'max') {
              this.next();
              const n = this.expect('NUMBER');
              max = n.value;
              continue;
            }
            if (p.type === 'IDENT' && String(p.value).toLowerCase() === 'dir') {
              this.next();
              const d = this.expect('IDENT');
              dir = String(d.value).toLowerCase();
              if (!['in','out','both'].includes(dir)) throw new Error('dir must be in|out|both');
              continue;
            }
            if (p.type === 'IDENT' && String(p.value).toLowerCase() === 'edge') {
              this.next();
              this.expect('IDENT', 'where');
              edgeWhere = this.parseExpr();
              continue;
            }
            break;
          }
          return { kind: 'path', from, to, max, dir, edgeWhere };
        }
        throw new Error(`Unknown statement keyword: ${kw}`);
      }

      parseExpr() { return this.parseOr(); }
      parseOr() {
        let left = this.parseAnd();
        while (this.peek().type === 'IDENT' && String(this.peek().value).toLowerCase() === 'or') {
          this.next();
          const right = this.parseAnd();
          left = { kind: 'or', left, right };
        }
        return left;
      }
      parseAnd() {
        let left = this.parseNot();
        while (this.peek().type === 'IDENT' && String(this.peek().value).toLowerCase() === 'and') {
          this.next();
          const right = this.parseNot();
          left = { kind: 'and', left, right };
        }
        return left;
      }
      parseNot() {
        if (this.peek().type === 'IDENT' && String(this.peek().value).toLowerCase() === 'not') {
          this.next();
          const inner = this.parseNot();
          return { kind: 'not', inner };
        }
        return this.parsePrimary();
      }
      parsePrimary() {
        if (this.match('(', '(')) {
          const inner = this.parseExpr();
          this.expect(')', ')');
          return inner;
        }

        if (this.peek().type === 'IDENT' && String(this.peek().value).toLowerCase() === 'exists') {
          this.next();
          this.expect('(', '(');
          const field = this.parseField();
          this.expect(')', ')');
          return { kind: 'exists', field };
        }

        const field = this.parseField();
        const opTok = this.peek();
        if (opTok.type === 'IDENT' && String(opTok.value).toLowerCase() === 'in') {
          this.next();
          const list = this.parseList();
          return { kind: 'cmp', field, op: 'in', value: list };
        }
        if (opTok.type === 'OP') {
          const op = String(this.next().value);
          const value = this.parseValue();
          return { kind: 'cmp', field, op, value };
        }
        throw new Error('Expected comparison operator after field.');
      }

      parseField() {
        const t = this.expect('IDENT');
        return String(t.value).split('.');
      }

      parseList() {
        this.expect('(', '(');
        const items = [];
        if (this.match(')', ')')) return items;
        while (true) {
          items.push(this.parseValue());
          if (this.match(')', ')')) break;
          this.expect(',', ',');
        }
        return items;
      }

      parseValue() {
        const t = this.peek();
        if (t.type === 'STRING') return this.next().value;
        if (t.type === 'NUMBER') return this.next().value;
        if (t.type === 'IDENT') return String(this.next().value);
        throw new Error(`Expected value but got ${t.type}`);
      }
    }

    function compileExpr(ast, kind) {
      const evalField = (obj, fieldParts) => {
        if (!fieldParts || !fieldParts.length) return undefined;
        const root = String(fieldParts[0] || '');
        if (root === 'props') {
          const k = fieldParts.slice(1).join('.');
          return obj?.props ? obj.props[k] : undefined;
        }
        return obj ? obj[root] : undefined;
      };

      const toNum = (v) => {
        if (typeof v === 'number') return v;
        const n = Number(v);
        return isFinite(n) ? n : null;
      };

      const cmp = (left, op, right) => {
        if (op === '~') {
          const a = String(left ?? '').toLowerCase();
          const b = String(right ?? '').toLowerCase();
          return a.includes(b);
        }
        if (op === '=' || op === '!=') {
          const eq = String(left ?? '') === String(right ?? '');
          return (op === '=') ? eq : !eq;
        }
        if (op === '>' || op === '>=' || op === '<' || op === '<=') {
          const a = toNum(left);
          const b = toNum(right);
          if (a === null || b === null) return false;
          if (op === '>') return a > b;
          if (op === '>=') return a >= b;
          if (op === '<') return a < b;
          if (op === '<=') return a <= b;
        }
        if (op === 'in') {
          const arr = Array.isArray(right) ? right : [];
          const needle = String(left ?? '');
          return arr.map(x => String(x)).includes(needle);
        }
        return false;
      };

      const evalAst = (node, obj) => {
        if (!node) return false;
        if (node.kind === 'and') return evalAst(node.left, obj) && evalAst(node.right, obj);
        if (node.kind === 'or') return evalAst(node.left, obj) || evalAst(node.right, obj);
        if (node.kind === 'not') return !evalAst(node.inner, obj);
        if (node.kind === 'exists') {
          const v = evalField(obj, node.field);
          return v !== undefined && v !== null && String(v) !== '';
        }
        if (node.kind === 'cmp') {
          const v = evalField(obj, node.field);
          return cmp(v, node.op, node.value);
        }
        throw new Error(`Unknown expr node: ${node.kind}`);
      };

      if (kind !== 'node' && kind !== 'edge') throw new Error('compileExpr kind must be node|edge');
      return (obj) => evalAst(ast, obj);
    }

    // -------------------- Graph Viz (relational visual aid) --------------------
    let __heliosGraphViz = {
      key: null,
      running: false,
      paused: false,
      raf: 0,
      canvas: null,
      ctx: null,
      resizeObserver: null,
      nodes: [],
      edges: [],
      byId: new Map(),
      hoveredId: null,
      focusId: null,
      filterTypes: null,
      queryHighlightIds: null,
      queryHighlightEdgeKeys: null,
      width: 0,
      height: 0,
      dpr: 1,
      mode: 'force', // 'force' | 'map'
      geoBounds: null,
      geoCount: 0,
    };

    function _graphTypeFilterKey() {
      return 'helios_graph_node_type_filter';
    }

    function _getTypeFilterSet(availableTypes) {
      const all = new Set((availableTypes || []).map(t => String(t)));
      let raw = null;
      try { raw = localStorage.getItem(_graphTypeFilterKey()); } catch (_) {}
      if (!raw || raw === '*') return all;
      const parts = raw.split(',').map(s => s.trim()).filter(Boolean);
      const picked = new Set(parts);
      const anyValid = [...picked].some(t => all.has(t));
      if (!anyValid) return all;
      return new Set([...picked].filter(t => all.has(t)));
    }

    function _setTypeFilterSet(set, availableTypes) {
      const all = new Set((availableTypes || []).map(t => String(t)));
      const picked = new Set([...set].map(t => String(t)).filter(t => all.has(t)));
      const raw = picked.size === all.size ? '*' : [...picked].join(',');
      try { localStorage.setItem(_graphTypeFilterKey(), raw); } catch (_) {}
      __heliosGraphViz.filterTypes = picked;
    }

    function _renderGraphVizFilters(graph) {
      const holder = document.getElementById('graph-viz-filters');
      if (!holder) return;
      const types = (graph?.stats?.node_types && Array.isArray(graph.stats.node_types))
        ? graph.stats.node_types
        : [...new Set((graph?.nodes || []).map(n => n?.type).filter(Boolean))];
      const available = types.map(t => String(t)).sort();
      if (!available.length) {
        holder.innerHTML = '<span class="muted small">No node types available.</span>';
        return;
      }

      const selected = _getTypeFilterSet(available);
      __heliosGraphViz.filterTypes = selected;

      const mkBtn = (label, on, title) => {
        const b = document.createElement('button');
        b.className = `chip ${on ? 'active' : ''}`;
        b.textContent = label;
        if (title) b.title = title;
        return b;
      };

      holder.innerHTML = '';
      const allOn = selected.size === available.length;
      const allBtn = mkBtn('All', allOn, 'Show all node types');
      allBtn.addEventListener('click', () => {
        _setTypeFilterSet(new Set(available), available);
        renderGraph(window.__heliosGraph || null);
      });
      holder.appendChild(allBtn);

      available.forEach(tp => {
        const on = selected.has(tp);
        const b = mkBtn(tp, on, `Toggle type: ${tp}`);
        b.addEventListener('click', () => {
          const next = new Set(_getTypeFilterSet(available));
          if (next.has(tp)) next.delete(tp);
          else next.add(tp);
          if (!next.size) _setTypeFilterSet(new Set(available), available);
          else _setTypeFilterSet(next, available);
          renderGraph(window.__heliosGraph || null);
        });
        holder.appendChild(b);
      });
    }

    function toggleGraphVizPaused() {
      __heliosGraphViz.paused = !__heliosGraphViz.paused;
      return __heliosGraphViz.paused;
    }

    function stopGraphViz() {
      __heliosGraphViz.running = false;
      if (__heliosGraphViz.raf) cancelAnimationFrame(__heliosGraphViz.raf);
      __heliosGraphViz.raf = 0;
    }

    function resetGraphViz(graph) {
      // Force rebuild on next render.
      __heliosGraphViz.key = null;
      __heliosGraphViz.focusId = null;
      __heliosGraphViz.hoveredId = null;
      renderGraphViz(graph);
    }

    function _hash32(str) {
      // FNV-1a 32-bit
      let h = 2166136261;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }

    function _seededUnit(str) {
      // Deterministic pseudo-random in [0,1)
      const h = _hash32(String(str));
      // xorshift
      let x = h || 1;
      x ^= x << 13; x >>>= 0;
      x ^= x >> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return (x >>> 0) / 4294967296;
    }

    function _asFiniteNumber(v) {
      const n = typeof v === 'number' ? v : Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function _normalizeGeo(obj) {
      if (!obj || typeof obj !== 'object') return null;
      const lat = _asFiniteNumber(obj.lat ?? obj.latitude);
      const lon = _asFiniteNumber(obj.lon ?? obj.lng ?? obj.longitude);
      if (lat === null || lon === null) return null;
      if (Math.abs(lat) > 90 || Math.abs(lon) > 180) return null;
      return { lat, lon };
    }

    function _extractNodeGeo(nodeLike) {
      const props = nodeLike?.props || {};
      return _normalizeGeo(props.geo) || _normalizeGeo(props.location) || null;
    }

    function _computeGeoBounds(geoPoints) {
      let latMin = Infinity, latMax = -Infinity, lonMin = Infinity, lonMax = -Infinity;
      for (const g of geoPoints) {
        if (!g) continue;
        latMin = Math.min(latMin, g.lat);
        latMax = Math.max(latMax, g.lat);
        lonMin = Math.min(lonMin, g.lon);
        lonMax = Math.max(lonMax, g.lon);
      }
      if (!Number.isFinite(latMin) || !Number.isFinite(lonMin)) return null;
      // Avoid degenerate ranges.
      if (latMax - latMin < 1e-6) {
        latMin -= 0.001;
        latMax += 0.001;
      }
      if (lonMax - lonMin < 1e-6) {
        lonMin -= 0.001;
        lonMax += 0.001;
      }
      return { latMin, latMax, lonMin, lonMax };
    }

    function _projectLatLon(lat, lon, bounds, w, h, pad) {
      const x = pad + ((lon - bounds.lonMin) / (bounds.lonMax - bounds.lonMin)) * (w - pad * 2);
      // Invert latitude so north is up.
      const y = pad + ((bounds.latMax - lat) / (bounds.latMax - bounds.latMin)) * (h - pad * 2);
      return { x, y };
    }

    function _fmtDeg(v) {
      const n = _asFiniteNumber(v);
      if (n === null) return '';
      const abs = Math.abs(n);
      const digits = abs >= 10 ? 4 : 5;
      return n.toFixed(digits);
    }

    function _drawMapBackdrop(ctx, w, h, bounds) {
      // Light GPS/map-like grid + bounds labels.
      const pad = 24;
      ctx.save();
      ctx.fillStyle = 'rgba(10, 16, 32, 0.35)';
      ctx.fillRect(0, 0, w, h);

      const grid = 56;
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(154, 176, 214, 0.10)';
      ctx.beginPath();
      for (let x = pad; x <= w - pad; x += grid) {
        ctx.moveTo(x, pad);
        ctx.lineTo(x, h - pad);
      }
      for (let y = pad; y <= h - pad; y += grid) {
        ctx.moveTo(pad, y);
        ctx.lineTo(w - pad, y);
      }
      ctx.stroke();

      ctx.strokeStyle = 'rgba(232, 236, 245, 0.12)';
      ctx.strokeRect(pad, pad, w - pad * 2, h - pad * 2);

      if (bounds) {
        ctx.font = '11px IBM Plex Sans, system-ui, -apple-system, sans-serif';
        ctx.fillStyle = 'rgba(232, 236, 245, 0.72)';
        const tl = `${_fmtDeg(bounds.latMax)}, ${_fmtDeg(bounds.lonMin)}`;
        const tr = `${_fmtDeg(bounds.latMax)}, ${_fmtDeg(bounds.lonMax)}`;
        const bl = `${_fmtDeg(bounds.latMin)}, ${_fmtDeg(bounds.lonMin)}`;
        const br = `${_fmtDeg(bounds.latMin)}, ${_fmtDeg(bounds.lonMax)}`;
        ctx.fillText(tl, pad + 4, pad - 8);
        ctx.fillText(tr, Math.max(pad + 4, w - pad - ctx.measureText(tr).width), pad - 8);
        ctx.fillText(bl, pad + 4, h - pad + 16);
        ctx.fillText(br, Math.max(pad + 4, w - pad - ctx.measureText(br).width), h - pad + 16);
      }

      ctx.restore();
    }

    function _pickFocusNode(nodes, q) {
      if (!q) return null;
      const qq = q.toLowerCase();
      // Prefer exact id match, then prefix match, then label/type match.
      const exact = nodes.find(n => String(n.id || '').toLowerCase() === qq);
      if (exact) return exact;
      const prefix = nodes.find(n => String(n.id || '').toLowerCase().includes(qq));
      if (prefix) return prefix;
      const label = nodes.find(n => (`${n.label || ''} ${n.type || ''}`).toLowerCase().includes(qq));
      return label || null;
    }

    function _buildSubgraph(graph, q) {
      const nodes = Array.isArray(graph?.nodes) ? graph.nodes : [];
      const edges = Array.isArray(graph?.edges) ? graph.edges : [];
      const nodeById = new Map(nodes.map(n => [String(n.id), n]));

      const availableTypes = (graph?.stats?.node_types && Array.isArray(graph.stats.node_types))
        ? graph.stats.node_types
        : [...new Set(nodes.map(n => n?.type).filter(Boolean))];
      const allowedTypes = __heliosGraphViz.filterTypes || _getTypeFilterSet(availableTypes);

      const focus = _pickFocusNode(nodes, q);
      const keep = new Set();
      let focusId = null;
      if (focus && focus.id) {
        // If focus node type is filtered out, treat as no-focus.
        if (allowedTypes.has(String(focus.type || ''))) {
          focusId = String(focus.id);
          keep.add(focusId);
        }

        // 1-hop neighborhood (and a small 2-hop spillover if room).
        const neighbors = new Set();
        edges.forEach(e => {
          const s = String(e.source || '');
          const t = String(e.target || '');
          if (s === focusId) neighbors.add(t);
          if (t === focusId) neighbors.add(s);
        });
        [...neighbors].slice(0, 40).forEach(id => keep.add(id));

        if (keep.size < 60) {
          const neighborArray = [...neighbors];
          for (const nid of neighborArray) {
            edges.forEach(e => {
              const s = String(e.source || '');
              const t = String(e.target || '');
              if (keep.size >= 70) return;
              if (s === nid) keep.add(t);
              if (t === nid) keep.add(s);
            });
            if (keep.size >= 70) break;
          }
        }
      } else {
        // No focus: show a degree-heavy slice.
        const deg = new Map();
        edges.forEach(e => {
          const s = String(e.source || '');
          const t = String(e.target || '');
          deg.set(s, (deg.get(s) || 0) + 1);
          deg.set(t, (deg.get(t) || 0) + 1);
        });
        nodes
          .slice()
          .sort((a, b) => (deg.get(String(b.id)) || 0) - (deg.get(String(a.id)) || 0))
          .slice(0, 70)
          .forEach(n => keep.add(String(n.id)));
      }

      const subNodes = [...keep]
        .map(id => nodeById.get(id))
        .filter(Boolean);

      const filteredNodes = subNodes.filter(n => allowedTypes.has(String(n.type || '')));
      const filteredIds = new Set(filteredNodes.map(n => String(n.id)));
      const keepEdges = edges.filter(e => filteredIds.has(String(e.source || '')) && filteredIds.has(String(e.target || '')));
      return { nodes: filteredNodes, edges: keepEdges.slice(0, 140), focusId };
    }

    function _colorForType(type) {
      const palette = {
        event: '#4cf0b5',
        task: '#4c96f0',
        task_pending: '#f9c74f',
        case: '#c77dff',
        evidence: '#ff6b6b',
        hypothesis: '#ffd166',
        entity: '#06d6a0',
        track: '#8ecae6',
        camera: '#bde0fe',
        source: '#a0aec0',
      };
      return palette[String(type || '').toLowerCase()] || '#9ab0d6';
    }

    function _setupGraphVizCanvas() {
      const canvas = document.getElementById('graph-viz');
      if (!canvas) return null;

      const ctx = canvas.getContext('2d');
      if (!ctx) return null;

      __heliosGraphViz.canvas = canvas;
      __heliosGraphViz.ctx = ctx;

      const resize = () => {
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
        const w = Math.max(200, Math.floor(rect.width));
        const h = Math.max(240, Math.floor(rect.height));
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        __heliosGraphViz.width = w;
        __heliosGraphViz.height = h;
        __heliosGraphViz.dpr = dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      };

      if (__heliosGraphViz.resizeObserver) {
        try { __heliosGraphViz.resizeObserver.disconnect(); } catch (_) {}
      }
      __heliosGraphViz.resizeObserver = new ResizeObserver(() => resize());
      __heliosGraphViz.resizeObserver.observe(canvas);
      resize();

      const pick = (evt) => {
        const rect = canvas.getBoundingClientRect();
        const x = evt.clientX - rect.left;
        const y = evt.clientY - rect.top;
        let best = null;
        let bestD2 = Infinity;
        for (const n of __heliosGraphViz.nodes) {
          const dx = n.x - x;
          const dy = n.y - y;
          const d2 = dx * dx + dy * dy;
          if (d2 < bestD2) {
            bestD2 = d2;
            best = n;
          }
        }
        if (!best) return null;
        const r = (best.r || 6) + 6;
        return bestD2 <= r * r ? best : null;
      };

      canvas.onmousemove = (evt) => {
        const hit = pick(evt);
        __heliosGraphViz.hoveredId = hit ? hit.id : null;
      };

      canvas.onclick = (evt) => {
        const hit = pick(evt);
        if (!hit) return;
        const input = document.getElementById('graph-search');
        if (input) input.value = String(hit.id);
        // Update tables + viz using the existing render path.
        renderGraph(window.__heliosGraph || null);
      };

      return { canvas, ctx };
    }

    function renderGraphViz(graph) {
      // Only render while the graph tab exists/visible.
      const grid = document.getElementById('intel-graph');
      if (!grid || grid.style.display === 'none') return;

      const canvas = document.getElementById('graph-viz');
      if (!canvas) return;
      const setup = _setupGraphVizCanvas();
      if (!setup) return;

      const q = (document.getElementById('graph-search')?.value || '').trim();
      try { _renderGraphVizFilters(graph); } catch (_) {}
      const { nodes, edges, focusId } = _buildSubgraph(graph, q);

      const geoPoints = nodes.map(n => _extractNodeGeo(n)).filter(Boolean);
      const bounds = geoPoints.length >= 2 ? _computeGeoBounds(geoPoints) : null;
      const mode = bounds ? 'map' : 'force';
      __heliosGraphViz.mode = mode;
      __heliosGraphViz.geoBounds = bounds;
      __heliosGraphViz.geoCount = geoPoints.length;

      const key = `${focusId || 'none'}|${nodes.map(n => n.id).join(',')}|${edges.length}|m:${mode}|g:${geoPoints.length}`;

      if (__heliosGraphViz.key !== key) {
        __heliosGraphViz.key = key;
        __heliosGraphViz.focusId = focusId;
        __heliosGraphViz.nodes = [];
        __heliosGraphViz.edges = [];
        __heliosGraphViz.byId = new Map();

        const w = __heliosGraphViz.width || 800;
        const h = __heliosGraphViz.height || 360;
        const cx = w / 2;
        const cy = h / 2;
        const radius = Math.min(w, h) * 0.32;

        nodes.forEach((n, idx) => {
          const id = String(n.id);
          const t = String(n.type || 'node');
          const seed = _seededUnit(id);
          const ang = (seed * Math.PI * 2) + (idx * 0.03);
          const rr = radius * (0.55 + _seededUnit(id + ':r') * 0.45);
          const geo = (mode === 'map') ? _extractNodeGeo(n) : null;
          const pinned = !!geo && !!bounds;
          const pad = 24;
          const proj = (pinned && bounds) ? _projectLatLon(geo.lat, geo.lon, bounds, w, h, pad) : null;
          const obj = {
            id,
            type: t,
            label: String(n.label || n.id || ''),
            color: _colorForType(t),
            x: proj ? proj.x : (cx + Math.cos(ang) * rr),
            y: proj ? proj.y : (cy + Math.sin(ang) * rr),
            vx: 0,
            vy: 0,
            r: (id === focusId) ? 8 : 6,
            props: n.props || {},
            geo,
            pinned,
            tx: proj ? proj.x : null,
            ty: proj ? proj.y : null,
          };
          __heliosGraphViz.nodes.push(obj);
          __heliosGraphViz.byId.set(id, obj);
        });

        edges.forEach(e => {
          const s = __heliosGraphViz.byId.get(String(e.source || ''));
          const t = __heliosGraphViz.byId.get(String(e.target || ''));
          if (!s || !t) return;
          __heliosGraphViz.edges.push({ s, t, type: String(e.type || 'REL') });
        });

        // Legend
        const legend = document.getElementById('graph-viz-legend');
        if (legend) {
          const types = [...new Set(__heliosGraphViz.nodes.map(n => n.type))].slice(0, 12);
          legend.innerHTML = types.map(tp => {
            const c = _colorForType(tp);
            return `<span><span class="swatch" style="background:${c}"></span>${escapeHtml(tp)}</span>`;
          }).join('');
        }
      }

      if (!__heliosGraphViz.running) {
        __heliosGraphViz.running = true;
        __heliosGraphViz.paused = false;
        __heliosGraphViz.raf = requestAnimationFrame(_graphVizFrame);
      }
    }

    function _graphVizFrame() {
      if (!__heliosGraphViz.running) return;
      const ctx = __heliosGraphViz.ctx;
      const canvas = __heliosGraphViz.canvas;
      if (!ctx || !canvas) return;

      const w = __heliosGraphViz.width;
      const h = __heliosGraphViz.height;
      const nodes = __heliosGraphViz.nodes;
      const edges = __heliosGraphViz.edges;

      // Stop animating if graph tab is hidden.
      const grid = document.getElementById('intel-graph');
      if (!grid || grid.style.display === 'none') {
        stopGraphViz();
        return;
      }

      if (!__heliosGraphViz.paused) {
        const mapMode = __heliosGraphViz.mode === 'map' && __heliosGraphViz.geoBounds;

        const centerPull = mapMode ? 0.0022 : 0.0035;
        const repulse = mapMode ? 8200 : 9000;
        const spring = mapMode ? 0.010 : 0.012;
        const springLen = mapMode ? 85 : 70;
        const damping = mapMode ? 0.82 : 0.84;

        // If in map mode, keep geo-tagged nodes pinned to their projected positions.
        const bounds = __heliosGraphViz.geoBounds;
        if (mapMode && bounds) {
          const pad = 24;
          for (const n of nodes) {
            if (n.pinned && n.geo) {
              const p = _projectLatLon(n.geo.lat, n.geo.lon, bounds, w, h, pad);
              n.tx = p.x;
              n.ty = p.y;
              n.x = p.x;
              n.y = p.y;
              n.vx = 0;
              n.vy = 0;
            }
          }
        }

        // Centering (skip pinned nodes).
        const cx = w / 2;
        const cy = h / 2;
        for (const n of nodes) {
          if (mapMode && n.pinned) continue;
          n.vx += (cx - n.x) * centerPull;
          n.vy += (cy - n.y) * centerPull;
        }

        // Repulsion (O(n^2), bounded by small N)
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i];
            const b = nodes[j];
            if (mapMode && a.pinned && b.pinned) continue;
            let dx = a.x - b.x;
            let dy = a.y - b.y;
            let d2 = dx * dx + dy * dy;
            if (d2 < 20) d2 = 20;
            const f = repulse / d2;
            const inv = 1 / Math.sqrt(d2);
            dx *= inv; dy *= inv;
            if (!(mapMode && a.pinned)) {
              a.vx += dx * f;
              a.vy += dy * f;
            }
            if (!(mapMode && b.pinned)) {
              b.vx -= dx * f;
              b.vy -= dy * f;
            }
          }
        }

        // Springs
        for (const e of edges) {
          const dx = e.t.x - e.s.x;
          const dy = e.t.y - e.s.y;
          const dist = Math.max(10, Math.sqrt(dx * dx + dy * dy));
          const delta = dist - springLen;
          const f = delta * spring;
          const nx = dx / dist;
          const ny = dy / dist;
          if (!(mapMode && e.s.pinned)) {
            e.s.vx += nx * f;
            e.s.vy += ny * f;
          }
          if (!(mapMode && e.t.pinned)) {
            e.t.vx -= nx * f;
            e.t.vy -= ny * f;
          }
        }

        // Integrate
        for (const n of nodes) {
          if (mapMode && n.pinned) continue;
          n.vx *= damping;
          n.vy *= damping;
          n.x += n.vx;
          n.y += n.vy;
          // bounds
          n.x = Math.max(12, Math.min(w - 12, n.x));
          n.y = Math.max(12, Math.min(h - 12, n.y));
        }
      }

      // Draw
      ctx.clearRect(0, 0, w, h);

      const mapMode = __heliosGraphViz.mode === 'map' && __heliosGraphViz.geoBounds;
      if (mapMode) {
        _drawMapBackdrop(ctx, w, h, __heliosGraphViz.geoBounds);
      }

        // Edges (with optional query highlighting)
        const highlightEdges = __heliosGraphViz.queryHighlightEdgeKeys;
        if (highlightEdges && highlightEdges.size) {
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(154, 176, 214, 0.14)';
          ctx.beginPath();
          for (const e of edges) {
            const k = `${e.s.id}|${e.type}|${e.t.id}`;
            if (highlightEdges.has(k)) continue;
            ctx.moveTo(e.s.x, e.s.y);
            ctx.lineTo(e.t.x, e.t.y);
          }
          ctx.stroke();

          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(249, 199, 79, 0.55)';
          ctx.beginPath();
          for (const e of edges) {
            const k = `${e.s.id}|${e.type}|${e.t.id}`;
            if (!highlightEdges.has(k)) continue;
            ctx.moveTo(e.s.x, e.s.y);
            ctx.lineTo(e.t.x, e.t.y);
          }
          ctx.stroke();
        } else {
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(154, 176, 214, 0.18)';
          ctx.beginPath();
          for (const e of edges) {
            ctx.moveTo(e.s.x, e.s.y);
            ctx.lineTo(e.t.x, e.t.y);
          }
          ctx.stroke();
        }

      const hovered = __heliosGraphViz.hoveredId ? __heliosGraphViz.byId.get(__heliosGraphViz.hoveredId) : null;
      const focus = __heliosGraphViz.focusId ? __heliosGraphViz.byId.get(__heliosGraphViz.focusId) : null;

        // Nodes
        const highlightNodes = __heliosGraphViz.queryHighlightIds;
        for (const n of nodes) {
          const isFocus = focus && n.id === focus.id;
          const isHover = hovered && n.id === hovered.id;
          const isQuery = highlightNodes && highlightNodes.has(n.id);
          const r = isFocus ? 9 : isHover ? 8 : n.r;
          ctx.beginPath();
          ctx.fillStyle = n.color;
          ctx.globalAlpha = (isFocus || isHover) ? 0.95 : isQuery ? 0.92 : 0.78;
          ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          if (isQuery) {
            ctx.strokeStyle = 'rgba(249, 199, 79, 0.75)';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
          if (isFocus || isHover) {
            ctx.strokeStyle = 'rgba(232, 236, 245, 0.65)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
          }
        }

      // Label (hovered or focus)
      const labelNode = hovered || focus;
      const tip = document.getElementById('graph-viz-tip');
      if (labelNode) {
        ctx.font = '12px IBM Plex Sans, system-ui, -apple-system, sans-serif';
        ctx.fillStyle = 'rgba(232, 236, 245, 0.95)';
        const geoTxt = (labelNode.geo && Number.isFinite(labelNode.geo.lat) && Number.isFinite(labelNode.geo.lon))
          ? ` @ ${_fmtDeg(labelNode.geo.lat)}, ${_fmtDeg(labelNode.geo.lon)}`
          : '';
        const txt = `${labelNode.type}: ${labelNode.label}${geoTxt}`;
        const pad = 6;
        const tw = ctx.measureText(txt).width;
        const bx = Math.min(w - tw - pad * 2 - 8, Math.max(8, labelNode.x + 10));
        const by = Math.min(h - 26, Math.max(8, labelNode.y + 10));
        ctx.fillStyle = 'rgba(13, 21, 43, 0.85)';
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect ? ctx.roundRect(bx, by, tw + pad * 2, 22, 8) : ctx.rect(bx, by, tw + pad * 2, 22);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = 'rgba(232, 236, 245, 0.95)';
        ctx.fillText(txt, bx + pad, by + 15);

        if (tip) {
          const deg = edges.reduce((acc, e) => acc + ((e.s.id === labelNode.id || e.t.id === labelNode.id) ? 1 : 0), 0);
          const modeTxt = mapMode ? ` · map(${__heliosGraphViz.geoCount} geo)` : '';
          const coordTxt = (labelNode.geo && Number.isFinite(labelNode.geo.lat) && Number.isFinite(labelNode.geo.lon))
            ? ` · lat=${_fmtDeg(labelNode.geo.lat)} lon=${_fmtDeg(labelNode.geo.lon)}`
            : '';
          tip.textContent = `${labelNode.id} · type=${labelNode.type} · degree=${deg}${modeTxt}${coordTxt} · click to focus`;
        }
      } else {
        if (tip) {
          const modeTxt = mapMode ? `Map mode (${__heliosGraphViz.geoCount} nodes w/ geo). ` : '';
          tip.textContent = `${modeTxt}Hover a node to see details. Click a node to filter tables.`;
        }
      }

      __heliosGraphViz.raf = requestAnimationFrame(_graphVizFrame);
    }

    async function loadMetrics() {
      const kpi = document.getElementById('dashboard-kpis');
      const countersTable = document.getElementById('metrics-counters');
      const timingsTable = document.getElementById('metrics-timings');
      const explain = document.getElementById('metrics-explain');
      try {
        const METRIC_CATALOG = {
          // Timed pipeline stages (timer() produces *_seconds + *_count)
          helios_ingest_seconds: {
            meaning: 'Total time spent ingesting inputs (read/collect sensor data).',
            units: 'seconds (cumulative)',
            interpret: 'Compare against ingest_count to get average per run. Spikes often mean slower I/O or heavier media input.',
          },
          helios_ingest_count: {
            meaning: 'How many times ingest completed (i.e., pipeline runs that reached ingest).',
            units: 'runs',
            interpret: 'Use with ingest_seconds to estimate average ingest time.',
          },
          helios_fusion_seconds: {
            meaning: 'Total time spent fusing readings into higher-level objects (tracks/scene).',
            units: 'seconds (cumulative)',
            interpret: 'If fusion_seconds grows quickly per run, fusion work is heavier (more detections/tracks) or compute is constrained.',
          },
          helios_fusion_count: {
            meaning: 'How many times fusion completed.',
            units: 'runs',
            interpret: 'Use with fusion_seconds to estimate average fusion time.',
          },
          helios_rules_seconds: {
            meaning: 'Total time spent evaluating rules to produce events/tasks.',
            units: 'seconds (cumulative)',
            interpret: 'Higher per run usually means more readings/events or more rules firing.',
          },
          helios_rules_count: {
            meaning: 'How many times rules evaluation completed.',
            units: 'runs',
            interpret: 'Use with rules_seconds to estimate average rules time.',
          },
          helios_decision_seconds: {
            meaning: 'Total time spent producing recommended actions from tasks.',
            units: 'seconds (cumulative)',
            interpret: 'Usually small; if it grows, decision logic or suggestion formatting is heavier.',
          },
          helios_decision_count: {
            meaning: 'How many times action decision logic completed.',
            units: 'runs',
            interpret: 'Use with decision_seconds to estimate average decision time.',
          },
          helios_guardrails_seconds: {
            meaning: 'Total time spent applying safety guardrails (rate limits, per-asset limits).',
            units: 'seconds (cumulative)',
            interpret: 'Spikes can indicate many candidate actions being checked.',
          },
          helios_guardrails_count: {
            meaning: 'How many times guardrails evaluation completed.',
            units: 'runs',
            interpret: 'Use with guardrails_seconds to estimate average guardrails time.',
          },
          helios_risk_budget_seconds: {
            meaning: 'Total time spent evaluating risk budgets (holding or releasing risky actions).',
            units: 'seconds (cumulative)',
            interpret: 'If present, this stage enforces a "risk window" and may hold tasks when budgets are exceeded.',
          },
          helios_risk_budget_count: {
            meaning: 'How many times risk budget evaluation completed.',
            units: 'runs',
            interpret: 'Use with risk_budget_seconds to estimate average time.',
          },
          helios_autonomy_seconds: {
            meaning: 'Total time spent applying autonomy / human-in-the-loop gating.',
            units: 'seconds (cumulative)',
            interpret: 'This reflects policy/approval workflow logic, not human time. If it grows, more tasks are being processed.',
          },
          helios_autonomy_count: {
            meaning: 'How many times autonomy gating logic completed.',
            units: 'runs',
            interpret: 'Use with autonomy_seconds to estimate average time.',
          },
          helios_export_seconds: {
            meaning: 'Total time spent exporting artifacts (events/tasks/suggestions/graph/STIX/etc.).',
            units: 'seconds (cumulative)',
            interpret: 'Increases with more artifacts written or slower disk/network.',
          },
          helios_export_count: {
            meaning: 'How many times export completed.',
            units: 'runs',
            interpret: 'Use with export_seconds to estimate average export time.',
          },

          // Common counters
          helios_events_raw: {
            meaning: 'How many raw events were produced by rules (before governance filtering).',
            units: 'events (cumulative)',
            interpret: 'Higher can mean more detections/noise; compare with governance/audit to see what was filtered.',
          },
          helios_export_json_writes: {
            meaning: 'How many JSON export artifacts were written into out/.',
            units: 'writes (cumulative)',
            interpret: 'Useful to confirm the pipeline is emitting outputs (events.json, suggestions, graph.json, etc.).',
          },

          // Guardrail drops (cumulative)
          helios_guardrail_drop_total: {
            meaning: 'How many candidate tasks were dropped due to total action limit.',
            units: 'tasks (cumulative)',
            interpret: 'If this rises, overall action volume is hitting the configured cap.',
          },
          helios_guardrail_drop_domain: {
            meaning: 'How many tasks were dropped due to per-domain action limits.',
            units: 'tasks (cumulative)',
            interpret: 'If this rises, a specific domain is producing too many actions vs its configured limit.',
          },
          helios_guardrail_drop_per_event: {
            meaning: 'How many tasks were dropped due to per-event action limits.',
            units: 'tasks (cumulative)',
            interpret: 'If this rises, single events are generating too many actions.',
          },
          helios_guardrail_drop_per_asset: {
            meaning: 'How many tasks were dropped due to per-asset limits.',
            units: 'tasks (cumulative)',
            interpret: 'If this rises, repeated actions are targeting the same asset.',
          },
          helios_guardrail_drop_per_asset_pattern: {
            meaning: 'How many tasks were dropped due to per-asset pattern limits.',
            units: 'tasks (cumulative)',
            interpret: 'If this rises, an asset-matching pattern is hitting its configured limit.',
          },

          // Export/infrastructure adapter counters (if enabled)
          helios_export_webhook_success: { meaning: 'Webhook export successes.', units: 'count (cumulative)', interpret: 'If configured, confirms remote forwarding worked.' },
          helios_export_webhook_failed: { meaning: 'Webhook export failures.', units: 'count (cumulative)', interpret: 'If this rises, check network/config/endpoint.' },
          helios_export_task_jsonl_writes: { meaning: 'Task JSONL export writes.', units: 'writes (cumulative)', interpret: 'Shows task export activity.' },
          helios_export_infrastructure_writes: { meaning: 'Infrastructure export writes (actions JSONL).', units: 'writes (cumulative)', interpret: 'Shows response handoff output activity.' },
          helios_export_stix_writes: { meaning: 'STIX bundle export writes.', units: 'writes (cumulative)', interpret: 'Shows STIX output activity (if enabled).' },
          helios_infra_file_writes: { meaning: 'Infrastructure adapter file writes.', units: 'writes (cumulative)', interpret: 'Confirms file exporter is writing actions.' },
          helios_infra_actions_written: { meaning: 'Total actions written by infrastructure adapter.', units: 'actions (cumulative)', interpret: 'Rises with actions emitted.' },
          helios_infra_http_success: { meaning: 'Infrastructure HTTP forward successes.', units: 'count (cumulative)', interpret: 'Confirms remote forwarding worked (if enabled).' },
          helios_infra_http_failed: { meaning: 'Infrastructure HTTP forward failures.', units: 'count (cumulative)', interpret: 'If this rises, check endpoint and credentials.' },
        };

        const describeMetric = (key) => METRIC_CATALOG[key] || {
          meaning: 'No description available for this metric name yet.',
          units: key.endsWith('_seconds') ? 'seconds (cumulative)' : 'count (cumulative)',
          interpret: 'If you want, we can add a description for this metric in the UI glossary.',
        };

        const renderExplain = (lookup, sourceLabel) => {
          if (!explain) return;
          const keys = Object.keys(lookup || {}).sort();
          const stageSeconds = keys.filter(k => k.startsWith('helios_') && k.endsWith('_seconds'));
          const stageCounts = keys.filter(k => k.startsWith('helios_') && k.endsWith('_count'));
          const hasTimers = stageSeconds.length > 0 && stageCounts.length > 0;
          explain.innerHTML = `<div class="nl">
            <div class="k">Source</div>
            <div class="v">${escapeHtml(sourceLabel)}</div>
            <ul class="nl-list">
              <li><strong>All values are cumulative</strong> since the server started. Restarting the server resets them.</li>
              <li>Each timed stage produces two metrics: <code>helios_&lt;stage&gt;_seconds</code> (total time) and <code>helios_&lt;stage&gt;_count</code> (how many runs).</li>
              <li>Average time per run is approximately <code>seconds / count</code>${hasTimers ? '' : ' (when both are present)'}.</li>
              <li>Counts like <code>helios_guardrail_drop_*</code> explain why actions were limited (proportionality/safety controls).</li>
            </ul>
          </div>
          <details class="nl-raw" style="margin-top:10px;">
            <summary>Glossary (what each metric means)</summary>
            <table class="table" style="margin-top:10px;">
              <tr><th>Metric</th><th>Meaning</th><th>Units</th><th>How to interpret</th></tr>
              ${keys.slice(0, 60).map(k => {
                const d = describeMetric(k);
                return `<tr><td>${escapeHtml(k)}</td><td>${escapeHtml(d.meaning)}</td><td>${escapeHtml(d.units)}</td><td>${escapeHtml(d.interpret)}</td></tr>`;
              }).join('')}
            </table>
            ${keys.length > 60 ? `<div class="muted" style="margin-top:8px;">Showing first 60 metrics.</div>` : ''}
          </details>`;
        };

        if (demoMode) {
          const demo = getDemoState();
          const lookup = demo.metrics || {};

          renderExplain(lookup, 'Demo Data (seeded metrics)');

          const kpiKeys = ['helios_events_raw', 'helios_decision_count', 'helios_export_json_writes', 'helios_guardrails_count'];
          if (kpi) {
            kpi.innerHTML = '';
            kpiKeys.forEach(key => {
              const label = key.replace('helios_', '').replace(/_/g, ' ');
              const val = lookup[key] ?? '—';
              const card = document.createElement('div');
              card.className = 'kpi';
              card.innerHTML = `<div class="label">${label}</div><div class="value">${val}</div>`;
              kpi.appendChild(card);
            });
          }

          const counterKeys = [
            'helios_ingest_count',
            'helios_fusion_count',
            'helios_rules_count',
            'helios_events_raw',
            'helios_decision_count',
            'helios_guardrails_count',
            'helios_risk_budget_count',
            'helios_autonomy_count',
            'helios_export_json_writes',
          ];
          const timingKeys = [
            'helios_ingest_seconds',
            'helios_fusion_seconds',
            'helios_rules_seconds',
            'helios_decision_seconds',
            'helios_guardrails_seconds',
            'helios_risk_budget_seconds',
            'helios_autonomy_seconds',
          ];

          const renderCounters = (table, keys, emptyMsg) => {
            if (!table) return;
            if (!keys.length) {
              table.innerHTML = `<tr><td class="muted" colspan="4">${emptyMsg}</td></tr>`;
              return;
            }
            table.innerHTML = '<tr><th>Metric</th><th>Value</th><th>Meaning</th><th>How to interpret</th></tr>';
            keys.forEach(key => {
              const row = document.createElement('tr');
              const label = key.replace('helios_', '').replace(/_/g, ' ');
              const val = lookup[key];
              const d = describeMetric(key);
              row.innerHTML = `<td>${escapeHtml(label)}</td><td>${escapeHtml(val ?? '—')}</td><td>${escapeHtml(d.meaning)}</td><td>${escapeHtml(d.interpret)}</td>`;
              table.appendChild(row);
            });
          };

          const renderTimings = (table, keys, emptyMsg) => {
            if (!table) return;
            if (!keys.length) {
              table.innerHTML = `<tr><td class="muted" colspan="5">${emptyMsg}</td></tr>`;
              return;
            }
            table.innerHTML = '<tr><th>Stage</th><th>Total (s)</th><th>Runs</th><th>Avg (s/run)</th><th>Meaning</th></tr>';
            keys.forEach(key => {
              const row = document.createElement('tr');
              const label = key.replace('helios_', '').replace(/_seconds$/,'').replace(/_/g, ' ');
              const total = Number(lookup[key]);
              const countKey = key.replace(/_seconds$/, '_count');
              const runs = Number(lookup[countKey]);
              const avg = (isFinite(total) && isFinite(runs) && runs > 0) ? (total / runs) : null;
              const d = describeMetric(key);
              row.innerHTML = `<td>${escapeHtml(label)}</td><td>${escapeHtml(isFinite(total) ? total.toFixed(3) : (lookup[key] ?? '—'))}</td><td>${escapeHtml(isFinite(runs) ? runs : (lookup[countKey] ?? '—'))}</td><td>${escapeHtml(avg === null ? '—' : avg.toFixed(3))}</td><td>${escapeHtml(d.meaning)}</td>`;
              table.appendChild(row);
            });
          };

          renderCounters(countersTable, counterKeys, 'No counters');
          renderTimings(timingsTable, timingKeys, 'No timings');
          return;
        }

        const res = await fetch('/api/metrics');
        if (!res.ok) throw new Error('metrics not found');
        const text = await res.text();
        const lines = text.trim().split('\n').filter(Boolean);
        const metrics = lines.map(line => {
          const [name, val] = line.trim().split(/\s+/);
          const num = Number(val);
          return { name, val: isNaN(num) ? val : num };
        });

        const lookup = Object.fromEntries(metrics.map(m => [m.name, m.val]));

        renderExplain(lookup, 'Live metrics (/api/metrics)');
        const kpiKeys = ['helios_events_raw', 'helios_decision_count', 'helios_export_json_writes', 'helios_guardrails_count'];
        if (kpi) {
          kpi.innerHTML = '';
          kpiKeys.forEach(key => {
            const label = key.replace('helios_', '').replace(/_/g, ' ');
            const val = lookup[key] ?? '—';
            const card = document.createElement('div');
            card.className = 'kpi';
            card.innerHTML = `<div class="label">${label}</div><div class="value">${val}</div>`;
            kpi.appendChild(card);
          });
        }

        const counterKeys = [
          'helios_ingest_count',
          'helios_fusion_count',
          'helios_rules_count',
          'helios_events_raw',
          'helios_decision_count',
          'helios_guardrails_count',
          'helios_risk_budget_count',
          'helios_autonomy_count',
          'helios_export_json_writes',
        ];
        const timingKeys = [
          'helios_ingest_seconds',
          'helios_fusion_seconds',
          'helios_rules_seconds',
          'helios_decision_seconds',
          'helios_guardrails_seconds',
          'helios_risk_budget_seconds',
          'helios_autonomy_seconds',
        ];

        const renderCounters = (table, keys, emptyMsg) => {
          if (!table) return;
          if (!keys.length) {
            table.innerHTML = `<tr><td class="muted" colspan="4">${emptyMsg}</td></tr>`;
            return;
          }
          table.innerHTML = '<tr><th>Metric</th><th>Value</th><th>Meaning</th><th>How to interpret</th></tr>';
          keys.forEach(key => {
            const row = document.createElement('tr');
            const label = key.replace('helios_', '').replace(/_/g, ' ');
            const val = lookup[key];
            const d = describeMetric(key);
            row.innerHTML = `<td>${escapeHtml(label)}</td><td>${escapeHtml(val ?? '—')}</td><td>${escapeHtml(d.meaning)}</td><td>${escapeHtml(d.interpret)}</td>`;
            table.appendChild(row);
          });
        };

        const renderTimings = (table, keys, emptyMsg) => {
          if (!table) return;
          if (!keys.length) {
            table.innerHTML = `<tr><td class="muted" colspan="5">${emptyMsg}</td></tr>`;
            return;
          }
          table.innerHTML = '<tr><th>Stage</th><th>Total (s)</th><th>Runs</th><th>Avg (s/run)</th><th>Meaning</th></tr>';
          keys.forEach(key => {
            const row = document.createElement('tr');
            const label = key.replace('helios_', '').replace(/_seconds$/,'').replace(/_/g, ' ');
            const total = Number(lookup[key]);
            const countKey = key.replace(/_seconds$/, '_count');
            const runs = Number(lookup[countKey]);
            const avg = (isFinite(total) && isFinite(runs) && runs > 0) ? (total / runs) : null;
            const d = describeMetric(key);
            row.innerHTML = `<td>${escapeHtml(label)}</td><td>${escapeHtml(isFinite(total) ? total.toFixed(3) : (lookup[key] ?? '—'))}</td><td>${escapeHtml(isFinite(runs) ? runs : (lookup[countKey] ?? '—'))}</td><td>${escapeHtml(avg === null ? '—' : avg.toFixed(3))}</td><td>${escapeHtml(d.meaning)}</td>`;
            table.appendChild(row);
          });
        };

        renderCounters(countersTable, counterKeys, 'No counters');
        renderTimings(timingsTable, timingKeys, 'No timings');
      } catch (e) {
        if (kpi) kpi.innerHTML = '';
        if (countersTable) countersTable.innerHTML = '<tr><td class="muted" colspan="4">metrics.prom not found</td></tr>';
        if (timingsTable) timingsTable.innerHTML = '<tr><td class="muted" colspan="5">metrics.prom not found</td></tr>';
        if (explain) explain.textContent = 'Metrics not available yet. Run the pipeline to generate out/metrics.prom.';
      }
    }

    async function loadConfig() {
      try {
        if (demoMode) {
          const demo = getDemoState();
          guardrailCfgCache = demo.cfg;
          renderApprovals(demo.cfg);
          renderGuardrails(demo.cfg);
          renderInfra(demo.cfg);
          renderModules(demo.cfg);
          return;
        }
        const res = await fetch('/api/config');
        const text = await res.text();
        const cfg = jsyaml.load(text);
        guardrailCfgCache = cfg;
        renderApprovals(cfg);
        renderGuardrails(cfg);
        renderInfra(cfg);
        renderModules(cfg);
      } catch (e) {
        console.error('Config load failed', e);
      }
    }

    async function loadEvents() {
      try {
        if (demoMode) {
          const demo = getDemoState();
          const events = demo.events || [];
          const tasks = demo.tasks || [];
          latestEvents = events;
          latestTasks = tasks;
          document.getElementById('events-count').textContent = events.length;
          document.getElementById('tasks-count').textContent = tasks.length;
          renderEventsTasks(events, tasks);
          updateAssetSelectors();
          renderIntents(demo.intents || []);
          renderPlaybookActions(demo.playbook_actions || []);
          latestCommands = [...(demo.platform_commands || []), ...localQueuedCommands];
          renderPlatformCommands(latestCommands);
          renderAssets(demo.assets || []);
          return;
        }
        const res = await fetch('/api/events');
        if (!res.ok) throw new Error('events not found');
        const data = await res.json();
        const events = data.events || [];
        const tasks = data.tasks || [];
        latestEvents = events;
        latestTasks = tasks;
        document.getElementById('events-count').textContent = events.length;
        document.getElementById('tasks-count').textContent = tasks.length;
        renderEventsTasks(events, tasks);
        updateAssetSelectors();
      } catch (e) {
        document.getElementById('events-preview').innerHTML = '<li>No events.json yet. Run the pipeline or modules_media ingest.</li>';
      }
    }

    async function loadIntentsAndCommands() {
      try {
        if (demoMode) {
          const demo = getDemoState();
          renderIntents(demo.intents || []);
          renderPlaybookActions(demo.playbook_actions || []);
          latestAssets = demo.assets || [];
          latestAssetsSource = 'demo';
          renderAssets(latestAssets, latestAssetsSource);
          latestCommands = [...(demo.platform_commands || []), ...localQueuedCommands];
          renderPlatformCommands(latestCommands);
          return;
        }
        const [intentsRes, playbookRes, cmdsRes, assetsRes] = await Promise.all([
          fetch('/api/intents'),
          fetch('/api/playbook_actions'),
          fetch('/api/platform_commands'),
          fetch('/api/assets'),
        ]);
        const intents = intentsRes.ok ? (await intentsRes.json()).intents || [] : [];
        const actions = playbookRes.ok ? (await playbookRes.json()).actions || [] : [];
        const commands = cmdsRes.ok ? (await cmdsRes.json()).commands || [] : [];
        const assetsPayload = assetsRes.ok ? await assetsRes.json() : {};
        const assets = Array.isArray(assetsPayload) ? assetsPayload : (assetsPayload.assets || []);
        latestAssets = assets;
        latestAssetsSource = assetsRes.ok ? 'api' : latestAssetsSource;
        renderIntents(intents);
        renderPlaybookActions(actions);
        renderAssets(assets, latestAssetsSource);
        latestCommands = [...commands, ...localQueuedCommands];
        renderPlatformCommands(latestCommands);
      } catch (e) {
        renderIntents([]);
        renderPlaybookActions([]);
        renderPlatformCommands(localQueuedCommands);
        renderAssets([], latestAssetsSource);
      }
    }

    function renderIntents(intents) {
      const list = document.getElementById('intents-preview');
      if (!list) return;
      list.innerHTML = '';
      if (!intents || !intents.length) {
        list.innerHTML = '<li>No intent captured yet.</li>';
        return;
      }
      intents.slice(0, 12).forEach(intent => {
        const li = document.createElement('li');
        const effects = (intent.desired_effects || []).join(', ');
        const constraints = (intent.constraints || []).join(', ');
        li.innerHTML = `<div class="status-row"><strong>${escapeHtml(intent.text || intent.id || 'intent')}</strong>
          <span class="badge badge-live">${escapeHtml(intent.priority || 'prio?')}</span></div>
          <div class="muted small">domain: ${escapeHtml(intent.domain || 'multi')} · timing: ${escapeHtml(intent.timing || '—')}</div>
          <div class="muted small">effects: ${escapeHtml(effects || '—')}</div>
          <div class="muted small">constraints: ${escapeHtml(constraints || '—')}</div>`;
        list.appendChild(li);
      });
    }

    function renderPlaybookActions(actions) {
      const list = document.getElementById('playbook-preview');
      if (!list) return;
      list.innerHTML = '';
      if (!actions || !actions.length) {
        list.innerHTML = '<li>No playbook actions mapped yet.</li>';
        return;
      }
      actions.slice(0, 12).forEach(act => {
        const li = document.createElement('li');
        const badge = act.derived_from_intent ? `<span class="badge badge-live">from intent</span>` : '';
        li.innerHTML = `<div class="status-row"><strong>${escapeHtml(act.name || act.id || 'action')}</strong>${badge}</div>
          <div class="muted small">domain: ${escapeHtml(act.domain || 'multi')} · intent: ${escapeHtml(act.derived_from_intent || '—')}</div>
          <div class="muted small">params: ${escapeHtml(JSON.stringify(act.parameters || {}, null, 0))}</div>`;
        list.appendChild(li);
      });
    }

    function renderPlatformCommands(cmds) {
      const list = document.getElementById('platform-preview');
      if (!list) return;
      list.innerHTML = '';
      if (!cmds || !cmds.length) {
        list.innerHTML = '<li>No platform commands queued yet.</li>';
        return;
      }
      cmds.slice(0, 12).forEach(cmd => {
        const li = document.createElement('li');
        const status = (cmd.status || 'queued').toLowerCase();
        const badgeClass = status === 'sent' ? 'badge-live' : (status === 'deferred' ? 'badge-mock' : (status === 'queued_local' ? 'badge-mock' : ''));
        const link = cmd.link_state;
        const linkText = link ? `${link.available ? 'link up' : 'link down'}${link.window_ends_epoch ? ` until ${new Date(link.window_ends_epoch * 1000).toLocaleTimeString()}` : ''}` : 'link n/a';
        li.innerHTML = `<div class="status-row"><strong>${escapeHtml(cmd.command || cmd.id || 'cmd')}</strong>
            <span class="badge ${badgeClass}">${escapeHtml(status)}</span></div>
          <div class="muted small">target: ${escapeHtml(cmd.target || 'unknown')} · asset: ${escapeHtml(cmd.asset_id || '—')} · domain: ${escapeHtml(cmd.domain || 'multi')} · priority: ${escapeHtml(cmd.priority ?? '—')}</div>
          <div class="muted small">link: ${escapeHtml(linkText)} · local: ${(cmd.metadata && cmd.metadata.local) ? 'yes' : 'no'}</div>
          <div class="muted small">args: ${escapeHtml(JSON.stringify(cmd.args || {}, null, 0))}</div>`;
        list.appendChild(li);
      });
    }

    function renderAssets(assets, source) {
      const list = document.getElementById('assets-preview');
      latestAssets = assets || [];
      latestAssetsSource = source || latestAssetsSource || (demoMode ? 'demo' : 'api');
      if (!list) return;
      list.innerHTML = '';
      if (!latestAssets.length) {
        list.innerHTML = '<li>No assets yet. Define pipeline.platform.assets or run a scenario that assigns assets.</li>';
        updateAssetSelectors();
        updateFormationSourceUI();
        updateFormationRoster();
        renderFormationLegend([]);
        updateJointFormationSourceUI();
        updateJointFormationRoster();
        renderFormationLegendJoint([]);
        updateJointDomainCounts();
        setFormation3D('line', []);
        return;
      }
      ensureFormationVehicles(latestAssets.length || 6, latestAssets);
      ensureFormationVehiclesFor(formationSimJoint, latestAssets.length || 6, latestAssets);
      setFormation3D(formationSim.formation || 'line', latestAssets);
      if (formationSim.canvas && formationSim.formation) {
        setFormation(formationSim.formation, 'assets');
      }
      if (formationSimJoint.canvas && formationSimJoint.formation) {
        setFormationJoint(formationSimJoint.formation, 'assets');
      }
      latestAssets.slice(0, 12).forEach(asset => {
        const li = document.createElement('li');
        const link = asset.link_state;
        const linkBadge = link ? (link.available ? 'badge-live' : 'badge-mock') : '';
        const battery = asset.battery_pct != null ? `${Math.round(asset.battery_pct * 100)}%` : '—';
        const linkText = link ? `${link.available ? 'link up' : 'link down'}${link.window_ends_epoch ? ` until ${new Date(link.window_ends_epoch * 1000).toLocaleTimeString()}` : ''}` : 'link n/a';
        li.innerHTML = `<div class="status-row"><strong>${escapeHtml(asset.label || asset.id)}</strong>
            <span class="badge ${linkBadge}">${escapeHtml(linkText)}</span></div>
          <div class="muted small">id: ${escapeHtml(asset.id)} · domain: ${escapeHtml(asset.domain || 'multi')} · type: ${escapeHtml(asset.vehicle_type || 'platform')}</div>
          <div class="muted small">status: ${escapeHtml(asset.status || 'unknown')} · battery: ${escapeHtml(battery)} · route pts: ${escapeHtml((asset.route || []).length)}</div>`;
        list.appendChild(li);
      });
      updateAssetSelectors();
      updateFormationSourceUI();
      updateFormationRoster();
      renderFormationLegend(latestAssets);
      updateJointFormationSourceUI();
      updateJointFormationRoster();
      renderFormationLegendJoint(latestAssets);
      updateJointDomainCounts();
    }

    function updateFormationSourceUI() {
      const badge = document.getElementById('formation-badge');
      const src = document.getElementById('formation-source');
      const isLive = latestAssetsSource === 'api' && latestAssets.length > 0 && !demoMode;
      if (badge) {
        badge.textContent = isLive ? 'Live' : 'Simulated';
        badge.className = `badge ${isLive ? 'badge-live' : 'badge-mock'}`;
      }
      if (src) {
        const label = isLive ? 'API (/api/assets)' : (latestAssetsSource === 'api' ? 'API (empty)' : 'Demo seed');
        src.textContent = label;
      }
    }

    function updateJointFormationSourceUI() {
      const badge = document.getElementById('joint-formation-badge');
      const src = document.getElementById('joint-formation-source');
      const isLive = latestAssetsSource === 'api' && latestAssets.length > 0 && !demoMode;
      if (badge) {
        badge.textContent = isLive ? 'Live' : 'Simulated';
        badge.className = `badge ${isLive ? 'badge-live' : 'badge-mock'}`;
      }
      if (src) {
        const label = isLive ? 'API (/api/assets)' : (latestAssetsSource === 'api' ? 'API (empty)' : 'Demo seed');
        src.textContent = label;
      }
    }

    function updateFormationRoster() {
      const list = document.getElementById('formation-vehicles');
      const count = document.getElementById('formation-vehicle-count');
      if (!list) return;
      list.innerHTML = '';
      const items = latestAssets || [];
      if (count) count.textContent = String(items.length || 0);
      if (!items.length) {
        list.innerHTML = '<li class="muted">No vehicles yet. Load assets via pipeline or demo.</li>';
        return;
      }
      items.slice(0, 20).forEach(a => {
        const link = a.link_state;
        const linkTxt = link ? `${link.available ? 'link up' : 'link down'}${link.window_ends_epoch ? ` until ${new Date(link.window_ends_epoch * 1000).toLocaleTimeString()}` : ''}` : 'link n/a';
        const li = document.createElement('li');
        li.innerHTML = `<strong>${escapeHtml(a.label || a.id)}</strong> · ${escapeHtml(a.domain || 'multi')} · ${escapeHtml(a.vehicle_type || 'platform')}<div class="muted small">${escapeHtml(linkTxt)}</div>`;
        list.appendChild(li);
      });
    }

    function updateJointFormationRoster() {
      const list = document.getElementById('joint-formation-vehicles');
      const count = document.getElementById('joint-formation-vehicle-count');
      if (!list) return;
      list.innerHTML = '';
      const items = latestAssets || [];
      if (count) count.textContent = String(items.length || 0);
      if (!items.length) {
        list.innerHTML = '<li class="muted">No vehicles yet. Load assets via pipeline or demo.</li>';
        return;
      }
      items.slice(0, 20).forEach(a => {
        const link = a.link_state;
        const linkTxt = link ? `${link.available ? 'link up' : 'link down'}${link.window_ends_epoch ? ` until ${new Date(link.window_ends_epoch * 1000).toLocaleTimeString()}` : ''}` : 'link n/a';
        const li = document.createElement('li');
        li.innerHTML = `<strong>${escapeHtml(a.label || a.id)}</strong> · ${escapeHtml(a.domain || 'multi')} · ${escapeHtml(a.vehicle_type || 'platform')}<div class="muted small">${escapeHtml(linkTxt)}</div>`;
        list.appendChild(li);
      });
    }

    function setFormationLegendCollapsed(collapsed) {
      formationLegendCollapsed = collapsed;
      const container = document.getElementById('formation-legend');
      const toggle = document.getElementById('formation-legend-toggle');
      const list = document.getElementById('formation-legend-list');
      if (container) {
        container.classList.toggle('collapsed', collapsed);
      }
      if (toggle) {
        toggle.textContent = collapsed ? '▼' : '▲';
        toggle.setAttribute('aria-expanded', (!collapsed).toString());
        toggle.setAttribute('title', collapsed ? 'Show voice commands' : 'Hide voice commands');
      }
      if (list) {
        list.style.display = collapsed ? 'none' : 'block';
      }
    }

    function setFormationLegendCollapsedJoint(collapsed) {
      jointFormationLegendCollapsed = collapsed;
      const container = document.getElementById('joint-formation-legend');
      const toggle = document.getElementById('joint-formation-legend-toggle');
      const list = document.getElementById('joint-formation-legend-list');
      if (container) {
        container.classList.toggle('collapsed', collapsed);
      }
      if (toggle) {
        toggle.textContent = collapsed ? '▼' : '▲';
        toggle.setAttribute('aria-expanded', (!collapsed).toString());
        toggle.setAttribute('title', collapsed ? 'Show voice commands' : 'Hide voice commands');
      }
      if (list) {
        list.style.display = collapsed ? 'none' : 'block';
      }
    }

    function renderFormationLegend() {
      const list = document.getElementById('formation-legend-list');
      if (!list) return;
      list.innerHTML = '';
      const entries = Object.entries(formationVoiceLegend);
      entries.forEach(([name, phrases]) => {
        const title = name.replace(/_/g, ' ');
        const li = document.createElement('li');
        li.innerHTML = `<strong>${escapeHtml(title)}</strong><div class="muted small">${escapeHtml((phrases || []).slice(0, 3).join(' · '))}</div>`;
        list.appendChild(li);
      });
      setFormationLegendCollapsed(formationLegendCollapsed);
    }

    function renderFormationLegendJoint() {
      const list = document.getElementById('joint-formation-legend-list');
      if (!list) return;
      list.innerHTML = '';
      const entries = Object.entries(formationVoiceLegendJoint);
      entries.forEach(([name, phrases]) => {
        const title = name.replace(/_/g, ' ');
        const li = document.createElement('li');
        li.innerHTML = `<strong>${escapeHtml(title)}</strong><div class="muted small">${escapeHtml((phrases || []).slice(0, 3).join(' · '))}</div>`;
        list.appendChild(li);
      });
      setFormationLegendCollapsedJoint(jointFormationLegendCollapsed);
    }

    function updateJointDomainCounts() {
      const air = document.getElementById('joint-air-count');
      const land = document.getElementById('joint-land-count');
      const sea = document.getElementById('joint-sea-count');
      if (!air && !land && !sea) return;
      const counts = { air: 0, land: 0, sea: 0 };
      (latestAssets || []).forEach(a => {
        const domain = (a.domain || '').toLowerCase();
        if (counts.hasOwnProperty(domain)) counts[domain] += 1;
      });
      if (air) air.textContent = String(counts.air);
      if (land) land.textContent = String(counts.land);
      if (sea) sea.textContent = String(counts.sea);
    }

    function setJointObjective(text) {
      const el = document.getElementById('joint-objective');
      if (el && text) el.textContent = text;
    }

    function updateAssetSelectors() {
      const assetSel = document.getElementById('asset-select');
      const eventSel = document.getElementById('asset-event-select');
      if (assetSel) {
        const prevAsset = assetSel.value;
        assetSel.innerHTML = '';
        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.textContent = 'Select asset';
        assetSel.appendChild(defaultOpt);
        latestAssets.forEach(a => {
          const opt = document.createElement('option');
          opt.value = a.id;
          opt.textContent = `${a.label || a.id} (${a.domain || 'multi'})`;
          assetSel.appendChild(opt);
        });
        if (prevAsset && latestAssets.some(a => a.id === prevAsset)) {
          assetSel.value = prevAsset;
        }
      }
      if (eventSel) {
        const prevEvent = eventSel.value;
        eventSel.innerHTML = '';
        const defaultEv = document.createElement('option');
        defaultEv.value = '';
        defaultEv.textContent = 'No specific event';
        eventSel.appendChild(defaultEv);
        latestEvents.forEach(ev => {
          const opt = document.createElement('option');
          opt.value = ev.id;
          opt.textContent = `${ev.id}: ${ev.summary || ev.category || ev.domain}`;
          eventSel.appendChild(opt);
        });
        if (prevEvent && latestEvents.some(ev => ev.id === prevEvent)) {
          eventSel.value = prevEvent;
        }
      }
    }

    function queueLocalCommand(commandTextOverride) {
      const eventSel = document.getElementById('asset-event-select');
      const assetSel = document.getElementById('asset-select');
      const domainInput = document.getElementById('asset-domain-input');
      const cmdInput = document.getElementById('asset-command-input');
      const statusEl = document.getElementById('asset-queue-status');
      if (!assetSel || !cmdInput || !statusEl) return;
      const assetId = assetSel.value;
      const cmdText = ((commandTextOverride ?? cmdInput.value) || '').trim();
      const eventId = eventSel ? eventSel.value : '';
      if (!assetId || !cmdText) {
        statusEl.textContent = 'Provide a command and pick an asset.';
        return;
      }
      const asset = latestAssets.find(a => a.id === assetId) || { domain: 'multi', link_state: null };
      const cmd = {
        id: `local-${Date.now()}`,
        command: cmdText,
        target: assetId,
        asset_id: assetId,
        domain: (domainInput?.value || asset.domain || 'multi'),
        status: 'queued_local',
        priority: 3,
        args: { event_id: eventId || undefined },
        link_state: asset.link_state || null,
        metadata: { local: true, from_ui: true, fallback: true },
      };
      localQueuedCommands = [cmd, ...localQueuedCommands];
      latestCommands = [cmd, ...latestCommands];
      renderPlatformCommands(latestCommands);
      statusEl.textContent = `Queued locally for ${assetId} (${cmdText}).`;
    }

    async function sendPlatformCommand() {
      const eventSel = document.getElementById('asset-event-select');
      const assetSel = document.getElementById('asset-select');
      const domainInput = document.getElementById('asset-domain-input');
      const cmdInput = document.getElementById('asset-command-input');
      const statusEl = document.getElementById('asset-queue-status');
      if (!assetSel || !cmdInput || !statusEl) return;
      const assetId = assetSel.value;
      const cmdText = (cmdInput.value || '').trim();
      const eventId = eventSel ? eventSel.value : '';
      if (!assetId || !cmdText) {
        statusEl.textContent = 'Provide a command and pick an asset.';
        return;
      }

      const maybeFormation = parseFormationFromText(cmdText);

      const asset = latestAssets.find(a => a.id === assetId) || { domain: 'multi', link_state: null };
      const domain = (domainInput?.value || asset.domain || 'multi');
      const payload = { text: cmdText, target: assetId, domain }; // Option B minimal + defaults
      if (eventId) payload.event_id = eventId;

      try {
        const res = await fetch('/api/platform_commands', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        const cmd = data.command || {};
        latestCommands = [cmd, ...latestCommands];
        renderPlatformCommands(latestCommands);
        statusEl.textContent = `Sent to API for ${assetId}.`;
        if (maybeFormation) {
          setFormation(maybeFormation, 'command');
          if (formationSimJoint.canvas) setFormationJoint(maybeFormation, 'command');
        }
      } catch (e) {
        statusEl.textContent = 'API send failed. Queued locally.';
        queueLocalCommand(cmdText);
        if (maybeFormation) {
          setFormation(maybeFormation, 'command-local');
          if (formationSimJoint.canvas) setFormationJoint(maybeFormation, 'command-local');
        }
      }
    }

    function queueJointCommandLocal(commandTextOverride) {
      const domainSel = document.getElementById('joint-domain-select');
      const cmdInput = document.getElementById('joint-command-input');
      const statusEl = document.getElementById('joint-command-status');
      if (!cmdInput || !statusEl) return;
      const cmdText = ((commandTextOverride ?? cmdInput.value) || '').trim();
      const domain = (domainSel?.value || 'multi');
      if (!cmdText) {
        statusEl.textContent = 'Provide a joint objective or command.';
        return;
      }
      const cmd = {
        id: `joint-local-${Date.now()}`,
        command: cmdText,
        target: 'joint-task-force',
        asset_id: 'joint-task-force',
        domain,
        status: 'queued_local',
        priority: 2,
        args: { objective: cmdText },
        metadata: { local: true, from_ui: true, joint: true, fallback: true },
      };
      localQueuedCommands = [cmd, ...localQueuedCommands];
      latestCommands = [cmd, ...latestCommands];
      renderPlatformCommands(latestCommands);
      statusEl.textContent = `Queued locally for joint tasking (${domain}).`;
      setJointObjective(cmdText);
    }

    async function sendJointCommand() {
      const domainSel = document.getElementById('joint-domain-select');
      const cmdInput = document.getElementById('joint-command-input');
      const statusEl = document.getElementById('joint-command-status');
      if (!cmdInput || !statusEl) return;
      const cmdText = (cmdInput.value || '').trim();
      const domain = (domainSel?.value || 'multi');
      if (!cmdText) {
        statusEl.textContent = 'Provide a joint objective or command.';
        return;
      }

      const maybeFormation = parseFormationFromText(cmdText, formationVoiceLegendJoint);

      const payload = { text: cmdText, target: 'joint-task-force', domain };

      try {
        const res = await fetch('/api/platform_commands', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        const cmd = data.command || {};
        latestCommands = [cmd, ...latestCommands];
        renderPlatformCommands(latestCommands);
        statusEl.textContent = `Sent to API for joint tasking (${domain}).`;
        if (maybeFormation) setFormationJoint(maybeFormation, 'command');
        setJointObjective(cmdText);
      } catch (e) {
        statusEl.textContent = 'API send failed. Queued locally.';
        queueJointCommandLocal(cmdText);
        if (maybeFormation) setFormationJoint(maybeFormation, 'command-local');
      }
    }

    async function loadAudit(tailOverride) {
      const tail = tailOverride || Number(document.getElementById('audit-tail')?.value || 120);
      try {
        if (demoMode) {
          const demo = getDemoState();
          latestAudit = (demo.audit || []).slice(-tail);
          renderAuditPreview(latestAudit.slice(-10));
          renderModulesStats();
          renderAuditSummaries();
          renderAuditTable();
          renderGuardrails();
          loadActionSuggestion();
          return;
        }
        const res = await fetch(`/api/audit?tail=${tail}`);
        if (!res.ok) throw new Error('audit not found');
        const data = await res.json();
        latestAudit = data.audit || [];
        renderAuditPreview(latestAudit.slice(-10));
        renderModulesStats();
        renderAuditSummaries();
        renderAuditTable();
        renderGuardrails();
        loadActionSuggestion();
      } catch (e) {
        latestAudit = [];
        moduleStatsCache = null;
        document.getElementById('audit-preview').innerHTML = '<li>No audit_log.jsonl yet.</li>';
        document.getElementById('modules-run-meta').textContent = 'Waiting for audit...';
        document.getElementById('modules-run-stats').textContent = 'No ingest run recorded yet. Run pipeline with ingest.mode: modules_media.';
        renderAuditSummaries(true);
        renderAuditTable(true);
        renderModuleDetails();
        renderGuardrails();
      }
    }

    async function loadActionSuggestion() {
      try {
        if (demoMode) {
          const demo = getDemoState();
          renderActionSuggestion(demo.suggestion);
          return;
        }
        const res = await fetch('/api/action_suggestion');
        if (!res.ok) throw new Error('suggestion not found');
        const data = await res.json();
        renderActionSuggestion(data);
      } catch (e) {
        renderActionSuggestion(null, true);
      }
    }

    function renderApprovals(cfg) {
      const actionDefaults = cfg?.pipeline?.infrastructure?.action_defaults || {};
      const rbacActions = cfg?.pipeline?.rbac?.action_requirements || {};
      const container = document.getElementById('approvals-content');
      container.innerHTML = '';
      Object.entries({ ...actionDefaults, ...rbacActions }).forEach(([action, vals]) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `<h3>${action}</h3>
          <div class="status-row"><span>Required Roles</span><span class="muted small">${(vals.required_roles || []).join(', ') || 'none'}</span></div>
          <div class="status-row"><span>Min Approvals</span><span class="muted small">${vals.min_approvals ?? 0}</span></div>
          <div class="status-row"><span>Status</span><span class="badge badge-live">Implemented</span></div>`;
        container.appendChild(card);
      });
      if (!container.childElementCount) {
        container.innerHTML = '<div class="card"><h3>No action defaults</h3><div class="muted">Add under pipeline.infrastructure.action_defaults.</div></div>';
      }
    }

    function renderGuardrails(cfg) {
      const source = cfg || guardrailCfgCache;
      const rate = source?.pipeline?.guardrails?.rate_limits || {};
      const riskBudgets = source?.pipeline?.guardrails?.risk_budgets || {};
      const healthThreshold = source?.pipeline?.guardrails?.health_alert_drop_ratio;
      const grid = document.getElementById('guardrails-cards');
      if (!grid) return;
      grid.innerHTML = '';

      const cards = [
        {
          title: 'Rate Limits',
          body: [
            ['Per Domain', rate.per_domain],
            ['Per Event', rate.per_event],
            ['Total', rate.total],
            ['Per Asset', rate.per_asset_infra],
            ['Per Asset Pattern', rate.per_asset_infra_patterns],
          ],
        },
        {
          title: 'Risk Budgets',
          body: Object.keys(riskBudgets).length
            ? Object.entries(riskBudgets).map(([tenant, vals]) => [tenant, vals])
            : [['None configured', '']],
        },
        {
          title: 'Health Alerts',
          body: [['Drop ratio alert threshold', healthThreshold ?? 'unset']],
        },
      ];

      cards.forEach(({ title, body }) => {
        const card = document.createElement('div');
        card.className = 'card';
        const rows = body.map(([label, val]) => {
          const display = typeof val === 'object' ? JSON.stringify(val, null, 2) : (val ?? 'unset');
          return `<div class="status-row"><span>${label}</span><span class="muted small">${display}</span></div>`;
        }).join('');
        card.innerHTML = `<h3>${title}</h3>${rows}<div class="status-row"><span>Status</span><span class="badge badge-live">Implemented</span></div>`;
        grid.appendChild(card);
      });
    }

    function renderInfra(cfg) {
      const infra = cfg?.pipeline?.export?.infrastructure || {};
      const path = infra.path || 'out/infrastructure_actions.jsonl';
      const el = document.getElementById('infra-file-status');
      const raw = document.getElementById('infra-file-status-raw');
      const sourceLabel = demoMode ? 'Demo Data (seeded config)' : 'Live config (/api/config)';
      if (el) {
        el.innerHTML = `<div class="nl">
          <div class="k">Exporter</div>
          <div class="v">Infrastructure actions file</div>
          <ul class="nl-list">
            <li>Path: ${escapeHtml(path)}</li>
            <li>Rotation: ${escapeHtml(infra.rotate_max_bytes || 'none')}</li>
            <li>HTTP forwarding: ${escapeHtml(infra.http ? 'configured' : 'not configured')}</li>
            <li>Source: ${escapeHtml(sourceLabel)}</li>
          </ul>
        </div>`;
      }
      if (raw) raw.textContent = JSON.stringify(infra, null, 2);
    }

    function renderModules(cfg) {
      const ingest = cfg?.pipeline?.ingest || {};
      const modules = ingest.modules || {};
      const media = ingest.media || {};
      modulesCfgCache = { modules, media, ingest };
      const grid = document.getElementById('modules-config');
      grid.innerHTML = '';

      const nav = document.getElementById('module-nav');
      if (nav) {
        nav.innerHTML = '';
        Object.entries(moduleCatalog).forEach(([key, meta]) => {
          const enabled = Boolean(modules[`enable_${key}`] ?? (key === 'gait' ? modules.enable_gait : false));
          const btn = document.createElement('button');
          btn.className = `chip ${selectedModule === key ? 'active' : ''}`;
          btn.dataset.module = key;
          btn.textContent = meta.title;
          if (!enabled) btn.style.opacity = 0.55;
          btn.addEventListener('click', () => {
            selectedModule = key;
            updateModuleNavActive();
            renderModuleDetails();
          });
          nav.appendChild(btn);
        });
        updateModuleNavActive();
      }

      const modeCard = document.createElement('div');
      modeCard.className = 'card';
      modeCard.innerHTML = `<h3>Ingest Setup</h3>
        <div class="nl">
          <div class="k">How sensors feed analytics</div>
          <div class="v">${escapeHtml(ingest.mode || 'unset')} mode</div>
          <ul class="nl-list">
            <li>Mode: <span class="badge ${ingest.mode === 'modules_media' ? 'badge-live' : 'badge-mock'}">${escapeHtml(ingest.mode || 'unset')}</span></li>
            <li>Input: ${escapeHtml(media.path || media.source || 'examples/scenario_minimal.yaml')}</li>
            <li>Stride: ${escapeHtml(media.stride ?? 8)} (process every Nth frame / window)</li>
            <li>Downscale: ${escapeHtml(media.downscale ?? modules.downscale ?? 1)}</li>
          </ul>
        </div>`;
      grid.appendChild(modeCard);

      const toggles = ['enable_vision', 'enable_audio', 'enable_thermal', 'enable_gait', 'enable_scene'];
      const togglesCard = document.createElement('div');
      togglesCard.className = 'card';
      const enabledList = toggles.map(name => ({
        key: name.replace('enable_', ''),
        on: Boolean(modules[name]),
      }));
      togglesCard.innerHTML = `<h3>Enabled Analytics</h3>
        <div class="nl">
          <div class="k">What the system will try to detect</div>
          <div class="v">${escapeHtml(enabledList.filter(x => x.on).map(x => x.key.toUpperCase()).join(' · ') || 'None')}</div>
          <ul class="nl-list">
            ${enabledList.map(x => `<li>${escapeHtml(x.key.toUpperCase())}: <span class="badge ${x.on ? 'badge-live' : 'badge-mock'}">${x.on ? 'on' : 'off'}</span></li>`).join('')}
          </ul>
        </div>`;
      grid.appendChild(togglesCard);

      const tuningCard = document.createElement('div');
      tuningCard.className = 'card';
      tuningCard.innerHTML = `<h3>How To Read Outputs</h3>
        <div class="nl">
          <div class="k">Output meaning</div>
          <div class="v">"Fragments" are module result chunks</div>
          <ul class="nl-list">
            <li>Counts are not people/vehicles directly; they’re detection/segment artifacts emitted by each module.</li>
            <li>High counts usually mean lots of motion, noise, or long dwell time in view.</li>
            <li>Low/zero counts can mean either a quiet scene or the module being disabled/misconfigured.</li>
          </ul>
        </div>`;
      grid.appendChild(tuningCard);

      renderModuleDetails();
      renderModulesStats();
    }

    function updateModuleNavActive() {
      const nav = document.getElementById('module-nav');
      if (!nav) return;
      nav.querySelectorAll('.chip').forEach(chip => {
        const key = chip.dataset.module;
        chip.classList.toggle('active', key === selectedModule);
      });
    }

    function renderModuleDetails() {
      const container = document.getElementById('module-details');
      if (!container) return;
      const modules = modulesCfgCache.modules || {};
      const media = modulesCfgCache.media || {};
      const key = moduleCatalog[selectedModule] ? selectedModule : Object.keys(moduleCatalog)[0];
      const meta = moduleCatalog[key];
      const enabled = Boolean(modules[`enable_${key}`] ?? (key === 'gait' ? modules.enable_gait : false));
      const stats = (moduleStatsCache && moduleStatsCache.stats) || {};
      const count = stats[key] ?? 0;
      const ingestPath = (moduleStatsCache && moduleStatsCache.path) || media.path || 'n/a';
      const stride = (moduleStatsCache && moduleStatsCache.stride) ?? media.stride ?? 8;
      const outputs = (meta.outputs || []).join(' · ');

      const outputMeaningByKey = {
        vision: 'detections, track updates, plate reads, and short action snippets',
        audio: 'sound-event segments and short transcript chunks',
        thermal: 'hotspot/anomaly segments from thermal frames',
        gait: 'gait embeddings tied to tracked people (non-identifying)',
        scene: 'fused scene-graph items combining multiple signals',
      };
      const meaning = outputMeaningByKey[key] || 'analysis artifacts';

      let headline = '';
      if (!enabled) headline = 'Disabled — no outputs expected.';
      else if (count > 0) headline = `Enabled — produced ${count} fragments last run.`;
      else headline = 'Enabled — no fragments observed last run.';

      const interpret = (() => {
        if (!enabled) return `Turn this on in config to generate ${meaning}.`;
        if (count === 0) return `If you expected signal here, check sensor coverage and whether stride/downscale is too aggressive.`;
        if (count < 10) return `Low activity: likely a quiet scene or a short observation window.`;
        if (count < 80) return `Moderate activity: typical of intermittent motion or a few short events.`;
        return `High activity: could indicate lots of motion, crowded scenes, or noisy conditions.`;
      })();

      container.innerHTML = `<h3>${meta.title}</h3>
        <p class="muted">${meta.desc}</p>
        <div class="nl">
          <div class="k">Summary</div>
          <div class="v">${escapeHtml(headline)}</div>
          <ul class="nl-list">
            <li>Status: <span class="badge ${enabled ? 'badge-live' : 'badge-mock'}">${enabled ? 'enabled' : 'disabled'}</span></li>
            <li>What counts represent: ${escapeHtml(meaning)}</li>
            <li>Last run: ${escapeHtml(count)} fragments</li>
            <li>Interpretation: ${escapeHtml(interpret)}</li>
            <li>Input: ${escapeHtml(ingestPath)}</li>
            <li>Stride: ${escapeHtml(stride)}</li>
            <li>Expected outputs: ${escapeHtml(outputs || '—')}</li>
          </ul>
        </div>`;
    }

    function renderActionSuggestion(data, empty = false) {
      const statusEl = document.getElementById('action-status');
      const pre = document.getElementById('action-preview');
      if (!statusEl || !pre) return;
      if (empty || !data) {
        statusEl.textContent = 'missing';
        statusEl.className = 'badge badge-mock';
        pre.innerHTML = '<li>No action suggestion available yet. Run modules_media or pipeline to generate.</li>';
        return;
      }
      statusEl.textContent = data.status || 'proposed';
      statusEl.className = `badge ${data.status === 'approved' ? 'badge-live' : data.status === 'denied' ? 'badge-mock' : 'badge-live'}`;
      const lines = [];
      lines.push(`Proposed at ${new Date((data.proposed_at || Date.now()) * 1000).toLocaleString()}`);
      if (data.plain_text) lines.push(`Plan: ${data.plain_text}`);
      if (data.recommended) {
        lines.push(`Action: ${data.recommended.action || 'action'} on ${data.recommended.asset_id || 'asset'} (${data.recommended.infrastructure_type || 'infra'}) domain ${data.recommended.assignee_domain || 'n/a'}`);
      }
      if (data.summary) {
        lines.push(`Context: ${data.summary.events_seen || 0} events, ${data.summary.tasks_approved || 0} approved tasks`);
      }
      if (data.decided_by) {
        lines.push(`Decision by ${data.decided_by}: ${data.status} (${data.decision_rationale || 'no rationale'})`);
      }
      pre.innerHTML = lines.map(t => `<li>${t}</li>`).join('');
    }

    function renderEventsTasks(events, tasks) {
      const list = document.getElementById('events-preview');
      if (!list) return;
      list.innerHTML = '';
      const topEvents = events.slice(0, 5);
      const topTasks = tasks.slice(0, 5);
      if (!topEvents.length && !topTasks.length) {
        list.innerHTML = '<li>No events or tasks yet.</li>';
        return;
      }
      topEvents.forEach(ev => {
        const li = document.createElement('li');
        const when = ev.ts_ms ? new Date(ev.ts_ms).toLocaleString() : 'recent';
        li.textContent = `[Event] ${ev.category || ev.id || 'unknown'} in ${ev.domain || 'domain'} (sev ${ev.severity_label || ev.severity || '?'}) at ${when}`;
        list.appendChild(li);
      });
      topTasks.forEach(t => {
        const li = document.createElement('li');
        li.textContent = `[Task] ${t.action || 'action'} -> ${t.asset_id || 'asset'} (${t.infrastructure_type || 'infra'}) domain ${t.assignee_domain || 'n/a'} status ${t.status || 'pending'}`;
        list.appendChild(li);
      });
    }

    function renderAuditPreview(entries) {
      const list = document.getElementById('audit-preview');
      if (!list) return;
      list.innerHTML = '';
      if (!entries || !entries.length) {
        list.innerHTML = '<li>No audit entries.</li>';
        return;
      }
      entries.forEach(evt => {
        const li = document.createElement('li');
        const ts = evt.ts_unix ? new Date(evt.ts_unix * 1000).toLocaleString() : '';
        li.textContent = `${ts}: ${evt.kind} — ${summarizeAuditPayload(evt)}`;
        list.appendChild(li);
      });
    }

    function summarizeAuditPayload(evt) {
      const kind = evt.kind;
      const p = evt.payload || {};
      switch (kind) {
        case 'ingest_modules_done':
          try {
            const stats = p.stats || {};
            const top = Object.entries(stats)
              .sort((a, b) => (b[1] ?? 0) - (a[1] ?? 0))
              .slice(0, 4)
              .map(([k, v]) => `${k} ${v}`)
              .join(' · ');
            return `modules_media ingest completed (stride ${p.stride ?? '—'}). Outputs: ${top || '—'}`;
          } catch (_) {
            return `modules_media ingest completed (stride ${p.stride ?? '—'}).`;
          }
        case 'rules_done':
          return `events ${p.events}, after governance ${p.events_after_governance}, blocked ${p.blocked}`;
        case 'guardrails':
          return `kept ${p.kept || 0} (drops ${JSON.stringify(p)})`;
        case 'action_suggestion':
          return `suggested ${p.recommended?.action || 'action'} for ${p.recommended?.asset_id || 'asset'} status ${p.status}`;
        case 'action_suggestion_decision':
          return `decision ${p.decision} for ${p.suggestion_id}`;
        default:
          return JSON.stringify(p);
      }
    }

    function renderModulesStats() {
      if (!Array.isArray(latestAudit) || !latestAudit.length) return;
      const ingestEvent = [...latestAudit].reverse().find(evt => evt.kind === 'ingest_modules_done');
      if (!ingestEvent) return;
      const payload = ingestEvent.payload || {};
      const stats = payload.stats || {};
      const summary = {
        path: payload.path,
        stride: payload.stride,
        modules_seen: Object.keys(stats).length,
      };
      moduleStatsCache = { stats, path: payload.path, stride: payload.stride, ts: ingestEvent.ts_unix, seq: ingestEvent.seq };
      document.getElementById('modules-run-meta').textContent = `seq ${ingestEvent.seq} · ${new Date(ingestEvent.ts_unix * 1000).toLocaleString()}`;
      const el = document.getElementById('modules-run-stats');
      const raw = document.getElementById('modules-run-stats-raw');
      const modulesList = Object.entries(stats)
        .sort((a, b) => (b[1] ?? 0) - (a[1] ?? 0))
        .slice(0, 8)
        .map(([k, v]) => {
          const label = (moduleCatalog[k]?.title) ? moduleCatalog[k].title : k;
          return `${label}: ${v}`;
        });
      if (el) {
        el.innerHTML = `<div class="nl">
          <div class="k">What happened</div>
          <div class="v">Modules ingest completed</div>
          <ul class="nl-list">
            <li>Input: ${escapeHtml(payload.path || '—')}</li>
            <li>Stride: ${escapeHtml(payload.stride ?? '—')}</li>
            <li>Modules with output: ${escapeHtml(Object.keys(stats).length)}</li>
            <li>Outputs (fragments): ${escapeHtml(modulesList.length ? modulesList.join(' · ') : '—')}</li>
            <li>How to interpret: more fragments usually means more motion/noise; fewer fragments can mean a quiet scene or disabled modules.</li>
          </ul>
        </div>`;
      }
      if (raw) raw.textContent = JSON.stringify({ summary, modules: stats }, null, 2);
      renderModuleDetails();
    }

    function renderAuditSummaries(empty = false) {
      const grid = document.getElementById('audit-summaries');
      if (!grid) return;
      grid.innerHTML = '';
      if (empty || !latestAudit.length) {
        grid.innerHTML = '<div class="card"><h3>No audit yet</h3><div class="muted">Run the pipeline to generate audit_log.jsonl.</div></div>';
        return;
      }
      const last = latestAudit[latestAudit.length - 1];
      const kinds = latestAudit.reduce((acc, evt) => {
        acc[evt.kind] = (acc[evt.kind] || 0) + 1;
        return acc;
      }, {});
      const kindList = Object.entries(kinds).sort((a, b) => b[1] - a[1]).slice(0, 4);
      const summaryCard = document.createElement('div');
      summaryCard.className = 'card';
      summaryCard.innerHTML = `<h3>Overview</h3>
        <div class="status-row"><span>Total entries</span><span class="muted small">${latestAudit.length}</span></div>
        <div class="status-row"><span>Last kind</span><span class="muted small">${last.kind}</span></div>
        <div class="status-row"><span>Latest seq</span><span class="muted small">${last.seq}</span></div>
        <div class="status-row"><span>Last time</span><span class="muted small">${new Date(last.ts_unix * 1000).toLocaleString()}</span></div>`;
      grid.appendChild(summaryCard);

      const kindsCard = document.createElement('div');
      kindsCard.className = 'card';
      kindsCard.innerHTML = `<h3>Top kinds</h3>${kindList.map(([k, v]) => `<div class="status-row"><span>${k}</span><span class="muted small">${v}</span></div>`).join('')}`;
      grid.appendChild(kindsCard);
    }

    function renderAuditTable(empty = false) {
      const table = document.getElementById('audit-table');
      if (!table) return;
      if (empty || !latestAudit.length) {
        table.innerHTML = '<tr><td class="muted" colspan="5">No audit entries yet.</td></tr>';
        return;
      }
      table.innerHTML = '<tr><th>Seq</th><th>Kind</th><th>Actor</th><th>Time</th><th>Description</th></tr>';
      latestAudit.slice().reverse().forEach(evt => {
        const row = document.createElement('tr');
        const desc = summarizeAuditPayload(evt);
        row.innerHTML = `<td>${evt.seq}</td><td>${evt.kind}</td><td>${evt.actor || 'n/a'}</td><td>${new Date(evt.ts_unix * 1000).toLocaleString()}</td><td>${desc}</td>`;
        table.appendChild(row);
      });
    }

    document.getElementById('mock-send').addEventListener('click', () => {
      const payload = [{ id: 'mock1', action: 'lock', asset_id: 'demo_gate', infrastructure_type: 'gate' }];
      document.getElementById('mock-result').textContent = 'Sending...';
      setTimeout(() => {
        document.getElementById('mock-result').textContent = 'Mock send recorded locally (no network).';
      }, 400);
    });

    const assetQueueBtn = document.getElementById('asset-send-btn');
    if (assetQueueBtn) {
      assetQueueBtn.addEventListener('click', sendPlatformCommand);
    }

    const jointCmdBtn = document.getElementById('joint-command-send');
    if (jointCmdBtn) {
      jointCmdBtn.addEventListener('click', sendJointCommand);
    }

    const voiceStartBtn = document.getElementById('voice-start');
    const voiceStopBtn = document.getElementById('voice-stop');
    if (voiceStartBtn) voiceStartBtn.addEventListener('click', startVoice);
    if (voiceStopBtn) voiceStopBtn.addEventListener('click', stopVoice);

    const auditRefreshBtn = document.getElementById('audit-refresh');
    if (auditRefreshBtn) {
      auditRefreshBtn.addEventListener('click', () => loadAudit());
    }
    const auditDownloadBtn = document.getElementById('audit-download');
    if (auditDownloadBtn) {
      auditDownloadBtn.addEventListener('click', () => {
        const blob = new Blob([JSON.stringify(latestAudit, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'audit_log_tail.json';
        a.click();
        URL.revokeObjectURL(url);
      });
    }

    const approveBtn = document.getElementById('action-approve');
    const denyBtn = document.getElementById('action-deny');
    const decide = async (decision) => {
      const actor = document.getElementById('action-actor')?.value || 'human';
      const token = document.getElementById('action-token')?.value || '';
      const rationale = document.getElementById('action-rationale')?.value || '';
      try {
        if (demoMode) {
          const demo = getDemoState();
          if (!demo.suggestion) demo.suggestion = { id: demoId('suggestion'), proposed_at: Math.floor(Date.now() / 1000), status: 'proposed' };
          demo.suggestion.status = decision === 'approve' ? 'approved' : 'denied';
          demo.suggestion.decided_at = Date.now() / 1000;
          demo.suggestion.decided_by = actor;
          demo.suggestion.decision_rationale = rationale;
          demo.audit = Array.isArray(demo.audit) ? demo.audit : [];
          const nextSeq = (demo.audit.length ? demo.audit[demo.audit.length - 1].seq : 0) + 1;
          demo.audit.push({
            seq: nextSeq,
            ts_unix: Math.floor(Date.now() / 1000),
            kind: 'action_suggestion_decision',
            actor,
            payload: { decision, rationale, suggestion_id: demo.suggestion.id },
          });
          renderActionSuggestion(demo.suggestion);
          loadAudit();
          return;
        }

        const res = await fetch('/api/action_suggestion', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ decision, actor, token, rationale }),
        });
        if (!res.ok) throw new Error('decision failed');
        const data = await res.json();
        renderActionSuggestion(data.suggestion);
        loadAudit();
      } catch (e) {
        alert('Failed to record decision.');
      }
    };
    if (approveBtn) approveBtn.addEventListener('click', () => decide('approve'));
    if (denyBtn) denyBtn.addEventListener('click', () => decide('deny'));

    // -------------------- Guided Tour (tutorial + simulation) --------------------
    (function setupGuidedTour() {
      const startBtn = document.getElementById('tour-start');
      if (!startBtn) return;

      let overlay = null;
      let card = null;
      let stepIndex = 0;
      let highlightedEl = null;
      let simulateMode = true; // default: no server writes

      function ensureOverlay() {
        if (overlay && card) return;
        overlay = document.createElement('div');
        overlay.className = 'tour-overlay';
        overlay.id = 'tour-overlay';
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) stopTour();
        });

        card = document.createElement('div');
        card.className = 'tour-card';
        card.innerHTML = `
          <div class="tour-title" id="tour-title">Guided Tour</div>
          <div class="tour-body" id="tour-body">Welcome.</div>
          <div class="tour-actions">
            <button class="pill-button" id="tour-back">Back</button>
            <button class="pill-button" id="tour-next">Next</button>
            <button class="pill-button" id="tour-exit">Exit</button>
          </div>
          <div class="tour-mini">
            <div id="tour-progress">Step 1/1</div>
            <label class="tour-toggle"><input type="checkbox" id="tour-sim" checked /> Simulate (no server writes)</label>
          </div>
        `;
        overlay.appendChild(card);
        document.body.appendChild(overlay);

        card.querySelector('#tour-exit')?.addEventListener('click', stopTour);
        card.querySelector('#tour-back')?.addEventListener('click', () => go(-1));
        card.querySelector('#tour-next')?.addEventListener('click', () => go(1));
        card.querySelector('#tour-sim')?.addEventListener('change', (e) => {
          simulateMode = Boolean(e.target.checked);
        });
      }

      function clearHighlight() {
        if (highlightedEl) highlightedEl.classList.remove('tour-highlight');
        highlightedEl = null;
      }

      function highlight(selector) {
        clearHighlight();
        if (!selector) return;
        const el = document.querySelector(selector);
        if (!el) return;
        highlightedEl = el;
        el.classList.add('tour-highlight');
        try {
          el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        } catch (_) {
          // ignore
        }
      }

      function navigateTo(hash) {
        if (!hash) return;
        const link = document.querySelector(`nav a[href="${hash}"]`);
        if (link) {
          link.click();
        } else {
          showPage(hash);
        }
      }

      function setTourText(title, body) {
        card.querySelector('#tour-title').textContent = title;
        card.querySelector('#tour-body').innerHTML = body;
        card.querySelector('#tour-progress').textContent = `Step ${stepIndex + 1}/${steps.length}`;
      }

      function demoEventsAndActions() {
        // Populate Live Feed with friendly sample content.
        const events = [
          {
            id: 'ev-demo-001',
            category: 'perimeter_anomaly',
            severity: 'warning',
            status: 'open',
            domain: 'facility',
            summary: 'Unusual movement detected near the north fence line',
            time_window: { start_ms: Date.now() - 120000, end_ms: Date.now() },
            entities: ['ent-demo-01'],
            sources: ['camera:north-fence'],
            tags: ['perimeter', 'after-hours'],
            evidence: [{ kind: 'CCTVClip', description: 'Short clip from north fence camera', uri: 'out/demo_clip.mp4' }],
          },
          {
            id: 'ev-demo-002',
            category: 'possible_tailgating',
            severity: 'notice',
            status: 'open',
            domain: 'access',
            summary: 'Door access pattern suggests possible tailgating',
            time_window: { start_ms: Date.now() - 300000, end_ms: Date.now() - 240000 },
            entities: [],
            sources: ['badge:door-A'],
            tags: ['access'],
            evidence: [],
          },
        ];
        const tasks = [
          {
            id: 'task-demo-001',
            event_id: 'ev-demo-001',
            action: 'dispatch_patrol',
            assignee_domain: 'security',
            priority: 3,
            rationale: 'Confirm area is clear and deter intrusion.',
            confidence: 0.74,
            status: 'approved',
            asset_id: 'north_fence',
            infrastructure_type: 'patrol',
          },
        ];
        renderEventsTasks(events, tasks);
        renderActionSuggestion({
          id: `suggestion-demo-${Date.now()}`,
          proposed_at: Date.now() / 1000,
          status: 'proposed',
          recommended: {
            action: 'dispatch_patrol',
            asset_id: 'north_fence',
            infrastructure_type: 'patrol',
            assignee_domain: 'security',
            rationale: 'Confirm area is clear and deter intrusion.',
          },
          summary: {
            events_seen: events.length,
            tasks_approved: tasks.length,
            tasks_pending: 0,
            top_event: { id: 'ev-demo-001', category: 'perimeter_anomaly', domain: 'facility', severity: 'warning' },
          },
          plain_text: 'Send a patrol to the north fence line and continue observation.',
        });
        document.getElementById('audit-preview').innerHTML = '<li>Demo: New activity received (simulated).</li><li>Demo: Recommendation prepared (simulated).</li>';
      }

      function demoCasebook() {
        // Populate the Casebook snapshot area with a safe example.
        const pre = document.getElementById('casebook-json');
        const meta = document.getElementById('casebook-meta');
        if (!pre || !meta) return;
        const cb = {
          schema_version: '0.1',
          cases: [{ id: 'case-demo-01', title: 'Night perimeter anomaly', description: 'Track repeated movement near north fence.', status: 'open', opened_at: Date.now() / 1000, domain: 'facility', classification: 'CUI' }],
          evidence: [{ id: 'ev-demo-01', kind: 'CCTVClip', description: 'North fence clip (simulated)', source: 'operator', created_at: Date.now() / 1000, uri: 'out/demo_clip.mp4', case_ids: ['case-demo-01'], tags: ['perimeter'], classification: 'CUI' }],
          hypotheses: [{ id: 'hyp-demo-01', title: 'Fence probing', description: 'Movement indicates probing for weak points.', status: 'open', confidence: 0.35, rationale: 'Repeated movement without entry attempt.', created_at: Date.now() / 1000, updated_at: Date.now() / 1000, case_ids: ['case-demo-01'], evidence_ids: ['ev-demo-01'], classification: 'CUI' }],
        };
        meta.textContent = `Demo casebook: ${cb.cases.length} case(s) · ${cb.evidence.length} evidence item(s) · ${cb.hypotheses.length} hypothesis/hypotheses.`;
        pre.textContent = JSON.stringify(cb, null, 2);
        try {
          window.__casebookSelectedId = cb.cases?.[0]?.id;
          renderCasebookReadable(cb);
        } catch (_) {
          // ignore
        }
      }

      function demoGraph() {
        const meta = document.getElementById('graph-meta');
        if (!meta) return;
        const graph = {
          schema_version: '0.1',
          generated_at: new Date().toISOString(),
          nodes: [
            { id: 'event:ev-demo-001', type: 'event', label: 'Unusual movement near north fence', props: { severity: 'warning', domain: 'facility', geo: { lat: 34.05220, lon: -118.24370 } } },
            { id: 'task:task-demo-001', type: 'task', label: 'dispatch_patrol', props: { status: 'approved' } },
            { id: 'case:case-demo-01', type: 'case', label: 'Night perimeter anomaly', props: { status: 'open' } },
            { id: 'evidence:ev-demo-01', type: 'evidence', label: 'North fence clip (simulated)', props: { kind: 'CCTVClip' } },
          ],
          edges: [
            { source: 'task:task-demo-001', type: 'RESPONDS_TO', target: 'event:ev-demo-001', props: {} },
            { source: 'evidence:ev-demo-01', type: 'EVIDENCE_FOR', target: 'case:case-demo-01', props: {} },
          ],
          stats: { nodes: 4, edges: 2, node_types: ['case', 'evidence', 'event', 'task'], edge_types: ['EVIDENCE_FOR', 'RESPONDS_TO'] },
        };
        window.__heliosGraph = graph;
        renderGraph(graph);
      }

      const steps = [
        {
          title: 'Welcome to Helios',
          body: 'This tour shows a typical workflow: <b>check activity</b>, <b>review safety</b>, <b>investigate</b>, and <b>act</b>. You can exit anytime.',
          go: () => { navigateTo('#dashboard'); highlight('#tour-start'); },
        },
        {
          title: 'Overview',
          body: 'Use <b>Overview</b> to get a quick sense of system health and speed.',
          go: () => { navigateTo('#dashboard'); highlight('#card-counters'); },
        },
        {
          title: 'Live feed (simulated)',
          body: 'This is where you see what was detected and the recommended response. During the tour we can simulate a recent run.',
          go: () => {
            navigateTo('#data');
            highlight('#events-preview');
            if (simulateMode) {
              setTimeout(demoEventsAndActions, 250);
            }
          },
        },
        {
          title: 'Review & approve',
          body: 'Use <b>Review</b> to confirm who can approve actions and what needs sign-off.',
          go: () => { navigateTo('#approvals'); highlight('#approvals-content'); },
        },
        {
          title: 'Investigations',
          body: 'Use <b>Investigate</b> to organize what you’ve seen into a case, attach evidence, and track hypotheses.',
          go: () => {
            navigateTo('#intel');
            highlight('#intel-nav');
            if (typeof initIntelUI === 'function') initIntelUI();
          },
        },
        {
          title: 'Casebook (simulated)',
          body: 'Here’s an example casebook entry. In simulation mode this does not write anything to disk.',
          go: () => {
            navigateTo('#intel');
            if (typeof initIntelUI === 'function') initIntelUI();
            selectedIntelTab = 'casebook';
            if (typeof updateIntelNavActive === 'function') updateIntelNavActive();
            if (typeof showIntelTab === 'function') showIntelTab('casebook');
            highlight('#casebook-readable');
            if (simulateMode) setTimeout(demoCasebook, 200);
          },
        },
        {
          title: 'Graph view (simulated)',
          body: 'The <b>Graph</b> view connects events, actions, cases, and evidence so relationships are easy to follow.',
          go: () => {
            navigateTo('#intel');
            if (typeof initIntelUI === 'function') initIntelUI();
            selectedIntelTab = 'graph';
            if (typeof updateIntelNavActive === 'function') updateIntelNavActive();
            if (typeof showIntelTab === 'function') showIntelTab('graph');
            highlight('#graph-nodes');
            if (simulateMode) setTimeout(demoGraph, 200);
          },
        },
        {
          title: 'Respond',
          body: 'Finally, <b>Respond</b> shows how actions would be handed off (this demo uses local files + a mock trigger).',
          go: () => { navigateTo('#infrastructure'); highlight('#mock-send'); },
        },
        {
          title: 'You’re done',
          body: 'Run a real scenario to see live data flow through the same pages. Tip: keep this tour handy for onboarding new operators.',
          go: () => { navigateTo('#dashboard'); clearHighlight(); },
        },
      ];

      function showStep() {
        ensureOverlay();
        overlay.classList.add('active');
        const s = steps[stepIndex];
        setTourText(s.title, s.body);
        clearHighlight();
        try { s.go(); } catch (_) { /* ignore */ }

        const back = card.querySelector('#tour-back');
        const next = card.querySelector('#tour-next');
        if (back) back.disabled = stepIndex === 0;
        if (next) next.textContent = stepIndex === steps.length - 1 ? 'Finish' : 'Next';
      }

      function go(delta) {
        const nextIndex = stepIndex + delta;
        if (nextIndex < 0) return;
        if (nextIndex >= steps.length) {
          stopTour();
          return;
        }
        stepIndex = nextIndex;
        showStep();
      }

      function startTour() {
        stepIndex = 0;
        simulateMode = true;
        showStep();
      }

      function stopTour() {
        clearHighlight();
        if (overlay) overlay.classList.remove('active');
        // Refresh live content after tour so the UI returns to real data.
        try { loadMetrics(); } catch (_) {}
        try { loadConfig(); } catch (_) {}
        try { loadEvents(); } catch (_) {}
        try { loadAudit(); } catch (_) {}
      }

      startBtn.addEventListener('click', startTour);
    })();

    initFormationViz();
    initFormationVizJoint();
    initVoice();
    loadMetrics();
    loadConfig();
    loadEvents();
    loadIntentsAndCommands();
    loadAudit();
    setInterval(loadMetrics, 5000);
    setInterval(loadEvents, 7000);
    setInterval(loadIntentsAndCommands, 7000);
    setInterval(loadAudit, 9000);
  </script>

  <!-- Failsafe navigation router (ES5) to ensure pages swap even if earlier script parsing is blocked in some browsers. -->
  <script>
    (function () {
      var navLinks = document.querySelectorAll('nav a');
      var pages = document.querySelectorAll('.page');

      function legacyShowPage(rawHash) {
        var target = rawHash || '#dashboard';
        if (target.charAt(0) !== '#') target = '#' + target;
        var pageId = target.slice(1) || 'dashboard';
        var found = false;

        for (var i = 0; i < pages.length; i++) {
          var p = pages[i];
          var match = p.id === pageId;
          p.style.display = match ? 'block' : 'none';
          if (match) found = true;
        }

        for (var j = 0; j < navLinks.length; j++) {
          var n = navLinks[j];
          if (n.getAttribute('href') === target) {
            n.classList.add('active');
          } else {
            n.classList.remove('active');
          }
        }

        if (!found && pageId !== 'dashboard') {
          return legacyShowPage('#dashboard');
        }

        if (pageId === 'dashboard' || pageId === 'data') {
          try { refreshFormationViz(); } catch (err) {}
        }
        if (pageId === 'joint') {
          try { refreshFormationVizJoint(); } catch (err) {}
        }
      }

      for (var k = 0; k < navLinks.length; k++) {
        (function (link) {
          link.addEventListener('click', function (e) {
            e.preventDefault();
            var href = link.getAttribute('href') || '#dashboard';
            legacyShowPage(href);
            try { window.location.hash = href; } catch (err) {}
          });
        })(navLinks[k]);
      }

      window.addEventListener('hashchange', function () {
        legacyShowPage(window.location.hash || '#dashboard');
      });

      legacyShowPage(window.location.hash || '#dashboard');
    })();
  </script>
</body>
</html>
